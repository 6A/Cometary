using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Reflection.Metadata;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Semantics;
using Microsoft.CodeAnalysis.Text;

namespace Cometary.Symbols
{
    partial class SymbolsFactory
    {
        public static extern IMethodSymbol AsyncConstructor(INamespaceOrTypeSymbol @stateMachineType);
        public static extern INamespaceOrTypeSymbol AsyncStateMachine(Object @variableAllocatorOpt, Object @compilationState, IMethodSymbol @asyncMethod, Int32 @asyncMethodOrdinal, TypeKind @typeKind);
        public static extern IMethodSymbol IteratorConstructor(INamespaceOrTypeSymbol @container);
        public static extern IMethodSymbol IteratorFinallyMethodSymbol(INamespaceOrTypeSymbol @stateMachineType, String @name);
        public static extern INamespaceOrTypeSymbol IteratorStateMachine(Object @slotAllocatorOpt, Object @compilationState, IMethodSymbol @iteratorMethod, Int32 @iteratorMethodOrdinal, Boolean @isEnumerable, INamespaceOrTypeSymbol @elementType);
        public static extern IMethodSymbol LambdaFrameConstructor(INamespaceOrTypeSymbol @frame);
        public static extern INamespaceOrTypeSymbol LambdaFrame(IMethodSymbol @topLevelMethod, IMethodSymbol @containingMethod, Boolean @isStruct, SyntaxNode @scopeSyntaxOpt, ValueType @methodId, ValueType @closureId);
        public static extern IMethodSymbol SynthesizedLambdaMethod(INamespaceOrTypeSymbol @containingType, ImmutableArray<INamespaceOrTypeSymbol> @structClosures, Enum @closureKind, IMethodSymbol @topLevelMethod, ValueType @topLevelMethodId,  @lambdaNode, ValueType @lambdaId);
        public static extern INamespaceOrTypeSymbol DynamicSiteContainer(String @name, IMethodSymbol @topLevelMethod);
        public static extern IFieldSymbol StateMachineFieldSymbol(INamespaceOrTypeSymbol @stateMachineType, INamespaceOrTypeSymbol @type, String @name, Boolean @isPublic, Boolean @isThis);
        public static extern IFieldSymbol StateMachineFieldSymbol(INamespaceOrTypeSymbol @stateMachineType, INamespaceOrTypeSymbol @type, String @name, Enum @synthesizedKind, Int32 @slotIndex, Boolean @isPublic);
        public static extern IFieldSymbol StateMachineFieldSymbol(INamespaceOrTypeSymbol @stateMachineType, INamespaceOrTypeSymbol @type, String @name, ValueType @slotDebugInfo, Int32 @slotIndex, Boolean @isPublic);
        public static extern IMethodSymbol SynthesizedStateMachineMoveNextMethod(IMethodSymbol @interfaceMethod, INamespaceOrTypeSymbol @stateMachineType);
        public static extern IMethodSymbol SynthesizedStateMachineDebuggerHiddenMethod(String @name, IMethodSymbol @interfaceMethod, INamespaceOrTypeSymbol @stateMachineType, IPropertySymbol @associatedProperty, Boolean @hasMethodBodyDependency);
        public static extern IMethodSymbol SynthesizedStringSwitchHashMethod(IModuleSymbol @containingModule, Object @privateImplType, INamespaceOrTypeSymbol @returnType, INamespaceOrTypeSymbol @paramType);
        public static extern IMethodSymbol SynthesizedExplicitImplementationForwardingMethod(IMethodSymbol @interfaceMethod, IMethodSymbol @implementingMethod, INamespaceOrTypeSymbol @implementingType);
        public static extern IMethodSymbol SynthesizedSealedPropertyAccessor(IPropertySymbol @property, IMethodSymbol @overriddenAccessor);
        public static extern IAssemblySymbol SourceAssemblySymbol(CSharpCompilation @compilation, String @assemblySimpleName, String @moduleName, ImmutableArray<Object> @netModules);
        public static extern INamespaceOrTypeSymbol PointerTypeSymbol(INamespaceOrTypeSymbol @pointedAtType);
        public static extern INamespaceOrTypeSymbol PointerTypeSymbol(INamespaceOrTypeSymbol @pointedAtType, ImmutableArray<CustomModifier> @customModifiers);
        public static extern IMethodSymbol SynthesizedPrivateImplementationDetailsStaticConstructor(IModuleSymbol @containingModule, Object @privateImplementationType, INamespaceOrTypeSymbol @voidType);
        public static extern IPropertySymbol SynthesizedStateMachineProperty(IMethodSymbol @interfacePropertyGetter, INamespaceOrTypeSymbol @stateMachineType);
        public static extern IAliasSymbol AliasSymbol(Object @binder, UsingDirectiveSyntax @syntax);
        public static extern IAliasSymbol AliasSymbol(Object @binder, ExternAliasDirectiveSyntax @syntax);
        public static extern IDiscardSymbol DiscardSymbol(INamespaceOrTypeSymbol @type);
        public static extern IFieldSymbol GlobalExpressionVariable(INamespaceOrTypeSymbol @containingType, Enum @modifiers, TypeSyntax @typeSyntax, String @name, SyntaxReference @syntax, Location @location);
        public static extern INamespaceOrTypeSymbol SynthesizedEmbeddedAttributeSymbol(ValueType @description, CSharpCompilation @compilation, Object @diagnostics);
        public static extern IEventSymbol TupleEventSymbol(INamespaceOrTypeSymbol @container, IEventSymbol @underlyingEvent);
        public static extern IFieldSymbol TupleFieldSymbol(INamespaceOrTypeSymbol @container, IFieldSymbol @underlyingField, Int32 @tupleElementIndex);
        public static extern IFieldSymbol TupleElementFieldSymbol(INamespaceOrTypeSymbol @container, IFieldSymbol @underlyingField, Int32 @tupleElementIndex, Location @location, Boolean @isImplicitlyDeclared, IFieldSymbol @correspondingDefaultFieldOpt);
        public static extern IFieldSymbol TupleVirtualElementFieldSymbol(INamespaceOrTypeSymbol @container, IFieldSymbol @underlyingField, String @name, Int32 @tupleElementIndex, Location @location, Boolean @cannotUse, Boolean @isImplicitlyDeclared, IFieldSymbol @correspondingDefaultFieldOpt);
        public static extern IMethodSymbol TupleMethodSymbol(INamespaceOrTypeSymbol @container, IMethodSymbol @underlyingMethod);
        public static extern IParameterSymbol TupleParameterSymbol(Object @container, IParameterSymbol @underlyingParameter);
        public static extern IFieldSymbol TupleErrorFieldSymbol(INamespaceOrTypeSymbol @container, String @name, Int32 @tupleElementIndex, Location @location, INamespaceOrTypeSymbol @type, Object @useSiteDiagnosticInfo, Boolean @isImplicitlyDeclared, IFieldSymbol @correspondingDefaultFieldOpt);
        public static extern IPropertySymbol TuplePropertySymbol(INamespaceOrTypeSymbol @container, IPropertySymbol @underlyingProperty);
        public static extern IMethodSymbol ConstructedMethodSymbol(IMethodSymbol @constructedFrom, ImmutableArray<INamespaceOrTypeSymbol> @typeArguments);
        public static extern INamespaceOrTypeSymbol SubstitutedNestedTypeSymbol(INamespaceOrTypeSymbol @newContainer, INamespaceOrTypeSymbol @originalDefinition);
        public static extern INamespaceOrTypeSymbol ConstructedNamedTypeSymbol(INamespaceOrTypeSymbol @constructedFrom, ImmutableArray<ValueType> @typeArguments, Boolean @unbound = false);
        public static extern IMethodSymbol ErrorMethodSymbol(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @returnType, String @name);
        public static extern IPropertySymbol ErrorPropertySymbol(Object @containingSymbol, INamespaceOrTypeSymbol @type, String @name, Boolean @isIndexer, Boolean @isIndexedProperty);
        public static extern INamespaceOrTypeSymbol ConstructedErrorTypeSymbol(INamespaceOrTypeSymbol @constructedFrom, ImmutableArray<ValueType> @typeArguments);
        public static extern INamespaceOrTypeSymbol SubstitutedNestedErrorTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, INamespaceOrTypeSymbol @originalDefinition);
        public static extern INamespaceOrTypeSymbol ExtendedErrorTypeSymbol(CSharpCompilation @compilation, String @name, Int32 @arity, Object @errorInfo, Boolean @unreported = false, Boolean @variableUsedBeforeDeclaration = false);
        public static extern INamespaceOrTypeSymbol ExtendedErrorTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, String @name, Int32 @arity, Object @errorInfo, Boolean @unreported = false, Boolean @variableUsedBeforeDeclaration = false);
        public static extern INamespaceOrTypeSymbol ExtendedErrorTypeSymbol(INamespaceOrTypeSymbol @guessSymbol, Enum @resultKind, Object @errorInfo, Boolean @unreported = false);
        public static extern INamespaceOrTypeSymbol ExtendedErrorTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, Object @guessSymbol, Enum @resultKind, Object @errorInfo, Boolean @unreported = false);
        public static extern INamespaceOrTypeSymbol ExtendedErrorTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, ImmutableArray<Object> @candidateSymbols, Enum @resultKind, Object @errorInfo, Int32 @arity, Boolean @unreported = false);
        public static extern IAssemblySymbol MissingAssemblySymbol(AssemblyIdentity @identity);
        public static extern IModuleSymbol MissingModuleSymbol(IAssemblySymbol @assembly, Int32 @ordinal);
        public static extern IModuleSymbol MissingModuleSymbolWithName(IAssemblySymbol @assembly, String @name);
        public static extern INamespaceOrTypeSymbol MissingNamespaceSymbol(IModuleSymbol @containingModule);
        public static extern INamespaceOrTypeSymbol MissingNamespaceSymbol(INamespaceOrTypeSymbol @containingNamespace, String @name);
        public static extern INamespaceOrTypeSymbol NoPiaAmbiguousCanonicalTypeSymbol(IAssemblySymbol @embeddingAssembly, INamespaceOrTypeSymbol @firstCandidate, INamespaceOrTypeSymbol @secondCandidate);
        public static extern INamespaceOrTypeSymbol NoPiaIllegalGenericInstantiationSymbol(IModuleSymbol @exposingModule, INamespaceOrTypeSymbol @underlyingSymbol);
        public static extern INamespaceOrTypeSymbol NoPiaMissingCanonicalTypeSymbol(IAssemblySymbol @embeddingAssembly, String @fullTypeName, String @guid, String @scope, String @identifier);
        public static extern IPreprocessingSymbol PreprocessingSymbol(String @name);
        public static extern IRangeVariableSymbol RangeVariableSymbol(String @Name, Object @containingSymbol, Location @location, Boolean @isTransparent = false);
        public static extern IMethodSymbol SignatureOnlyMethodSymbol(String @name, INamespaceOrTypeSymbol @containingType, MethodKind @methodKind, Enum @callingConvention, ImmutableArray<INamespaceOrTypeSymbol> @typeParameters, ImmutableArray<IParameterSymbol> @parameters, RefKind @refKind, INamespaceOrTypeSymbol @returnType, ImmutableArray<CustomModifier> @returnTypeCustomModifiers, ImmutableArray<CustomModifier> @refCustomModifiers, ImmutableArray<IMethodSymbol> @explicitInterfaceImplementations);
        public static extern IParameterSymbol SignatureOnlyParameterSymbol(INamespaceOrTypeSymbol @type, ImmutableArray<CustomModifier> @customModifiers, ImmutableArray<CustomModifier> @refCustomModifiers, Boolean @isParams, RefKind @refKind);
        public static extern IPropertySymbol SignatureOnlyPropertySymbol(String @name, INamespaceOrTypeSymbol @containingType, ImmutableArray<IParameterSymbol> @parameters, RefKind @refKind, INamespaceOrTypeSymbol @type, ImmutableArray<CustomModifier> @typeCustomModifiers, ImmutableArray<CustomModifier> @refCustomModifiers, Boolean @isStatic, ImmutableArray<IPropertySymbol> @explicitInterfaceImplementations);
        public static extern INamespaceOrTypeSymbol CrefTypeParameterSymbol(String @name, Int32 @ordinal, IdentifierNameSyntax @declaringSyntax);
        public static extern INamespaceOrTypeSymbol ImplicitNamedTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, Object @declaration, Object @diagnostics);
        public static extern IMethodSymbol LambdaSymbol(CSharpCompilation @compilation, Object @containingSymbol, IUnboundLambdaExpression @unboundLambda, ImmutableArray<INamespaceOrTypeSymbol> @parameterTypes, ImmutableArray<RefKind> @parameterRefKinds, RefKind @refKind, INamespaceOrTypeSymbol @returnType, Object @diagnostics);
        public static extern IMethodSymbol LambdaSymbol(Object @containingSymbol, Enum @messageID, SyntaxNode @syntax, Boolean @isSynthesized);
        public static extern IMethodSymbol LocalFunctionSymbol(Object @binder, Object @containingSymbol, LocalFunctionStatementSyntax @syntax);
        public static extern IParameterSymbol SourceClonedParameterSymbol(IParameterSymbol @originalParam, Object @newOwner, Int32 @newOrdinal, Boolean @suppressOptional);
        public static extern IParameterSymbol SourceComplexParameterSymbol(Object @owner, Int32 @ordinal, INamespaceOrTypeSymbol @parameterType, RefKind @refKind, String @name, ImmutableArray<Location> @locations, SyntaxReference @syntaxRef, Object @defaultSyntaxValue, Boolean @isParams, Boolean @isExtensionMethodThis);
        public static extern IParameterSymbol SourceComplexParameterSymbolWithCustomModifiers(Object @owner, Int32 @ordinal, INamespaceOrTypeSymbol @parameterType, RefKind @refKind, ImmutableArray<CustomModifier> @customModifiers, ImmutableArray<CustomModifier> @refCustomModifiers, String @name, ImmutableArray<Location> @locations, SyntaxReference @syntaxRef, Object @defaultSyntaxValue, Boolean @isParams, Boolean @isExtensionMethodThis);
        public static extern IMethodSymbol SourceCustomEventAccessorSymbol(IEventSymbol @event, AccessorDeclarationSyntax @syntax, IEventSymbol @explicitlyImplementedEventOpt, String @aliasQualifierOpt, Object @diagnostics);
        public static extern IEventSymbol SourceCustomEventSymbol(INamespaceOrTypeSymbol @containingType, Object @binder, EventDeclarationSyntax @syntax, Object @diagnostics);
        public static extern IMethodSymbol SourceDestructorSymbol(INamespaceOrTypeSymbol @containingType, DestructorDeclarationSyntax @syntax, Object @diagnostics);
        public static extern IFieldSymbol SourceEventFieldSymbol(IEventSymbol @associatedEvent, VariableDeclaratorSyntax @declaratorSyntax, Object @discardedDiagnostics);
        public static extern IEventSymbol SourceFieldLikeEventSymbol(INamespaceOrTypeSymbol @containingType, Object @binder, SyntaxTokenList @modifiers, VariableDeclaratorSyntax @declaratorSyntax, Object @diagnostics);
        public static extern IFieldSymbol SourceFixedFieldSymbol(INamespaceOrTypeSymbol @containingType, VariableDeclaratorSyntax @declarator, Enum @modifiers, Boolean @modifierErrors, Object @diagnostics);
        public static extern INamespaceOrTypeSymbol FixedFieldImplementationType(IFieldSymbol @field);
        public static extern ILabelSymbol SourceLabelSymbol(IMethodSymbol @containingMethod, SyntaxNodeOrToken @identifierNodeOrToken, Object @switchCaseLabelConstant);
        public static extern ILabelSymbol SourceLabelSymbol(IMethodSymbol @containingMethod, Object @switchCaseLabelConstant);
        public static extern IFieldSymbol SourceMemberFieldSymbolFromDeclarator(INamespaceOrTypeSymbol @containingType, VariableDeclaratorSyntax @declarator, Enum @modifiers, Boolean @modifierErrors, Object @diagnostics);
        public static extern IModuleSymbol SourceModuleSymbol(IAssemblySymbol @assemblySymbol, Object @declarations, String @moduleName);
        public static extern INamespaceOrTypeSymbol SourceNamedTypeSymbol(INamespaceOrTypeSymbol @containingSymbol, Object @declaration, Object @diagnostics);
        public static extern INamespaceOrTypeSymbol SourceNamespaceSymbol(IModuleSymbol @module, Object @container, Object @mergedDeclaration);
        public static extern IParameterSymbol SourceSimpleParameterSymbol(Object @owner, INamespaceOrTypeSymbol @parameterType, Int32 @ordinal, RefKind @refKind, String @name, ImmutableArray<Location> @locations);
        public static extern INamespaceOrTypeSymbol SourceTypeParameterSymbol(INamespaceOrTypeSymbol @owner, String @name, Int32 @ordinal, VarianceKind @varianceKind, ImmutableArray<Location> @locations, ImmutableArray<SyntaxReference> @syntaxRefs);
        public static extern INamespaceOrTypeSymbol SourceMethodTypeParameterSymbol(IMethodSymbol @owner, String @name, Int32 @ordinal, ImmutableArray<Location> @locations, ImmutableArray<SyntaxReference> @syntaxRefs);
        public static extern INamespaceOrTypeSymbol LocalFunctionTypeParameterSymbol(IMethodSymbol @owner, String @name, Int32 @ordinal, ImmutableArray<Location> @locations, ImmutableArray<SyntaxReference> @syntaxRefs);
        public static extern INamespaceOrTypeSymbol SourceOverridingMethodTypeParameterSymbol(Object @map, String @name, Int32 @ordinal, ImmutableArray<Location> @locations, ImmutableArray<SyntaxReference> @syntaxRefs);
        public static extern IParameterSymbol ThisParameterSymbol(IMethodSymbol @forMethod);
        public static extern IParameterSymbol ThisParameterSymbol(IMethodSymbol @forMethod, INamespaceOrTypeSymbol @containingType);
        public static extern IEventSymbol SubstitutedEventSymbol(INamespaceOrTypeSymbol @containingType, IEventSymbol @originalDefinition);
        public static extern IFieldSymbol SubstitutedFieldSymbol(INamespaceOrTypeSymbol @containingType, IFieldSymbol @substitutedFrom);
        public static extern IMethodSymbol SubstitutedMethodSymbol(INamespaceOrTypeSymbol @containingSymbol, IMethodSymbol @originalDefinition);
        public static extern IMethodSymbol SubstitutedMethodSymbol(INamespaceOrTypeSymbol @containingSymbol, Object @map, IMethodSymbol @originalDefinition, IMethodSymbol @constructedFrom);
        public static extern IParameterSymbol SubstitutedParameterSymbol(IMethodSymbol @containingSymbol, Object @map, IParameterSymbol @originalParameter);
        public static extern IParameterSymbol SubstitutedParameterSymbol(IPropertySymbol @containingSymbol, Object @map, IParameterSymbol @originalParameter);
        public static extern IPropertySymbol SubstitutedPropertySymbol(INamespaceOrTypeSymbol @containingType, IPropertySymbol @originalDefinition);
        public static extern INamespaceOrTypeSymbol SubstitutedTypeParameterSymbol(Object @newContainer, Object @map, INamespaceOrTypeSymbol @substitutedFrom, Int32 @ordinal);
        public static extern ILabelSymbol GeneratedLabelSymbol(String @name);
        public static extern IParameterSymbol SynthesizedAccessorValueParameterSymbol(IMethodSymbol @accessor, INamespaceOrTypeSymbol @paramType, Int32 @ordinal, ImmutableArray<CustomModifier> @customModifiers);
        public static extern IFieldSymbol SynthesizedBackingFieldSymbol(IPropertySymbol @property, String @name, Boolean @isReadOnly, Boolean @isStatic, Boolean @hasInitializer);
        public static extern INamespaceOrTypeSymbol SynthesizedDelegateSymbol(INamespaceOrTypeSymbol @containingSymbol, String @name, INamespaceOrTypeSymbol @objectType, INamespaceOrTypeSymbol @intPtrType, INamespaceOrTypeSymbol @voidReturnTypeOpt, Int32 @parameterCount, ValueType @byRefParameters);
        public static extern IFieldSymbol SynthesizedEnumValueFieldSymbol(INamespaceOrTypeSymbol @containingEnum);
        public static extern IMethodSymbol SynthesizedFieldLikeEventAccessorSymbol(IEventSymbol @event, Boolean @isAdder);
        public static extern IFieldSymbol SynthesizedFieldSymbol(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @type, String @name, Boolean @isPublic = false, Boolean @isReadOnly = false, Boolean @isStatic = false);
        public static extern IMethodSymbol SynthesizedInstanceConstructor(INamespaceOrTypeSymbol @containingType);
        public static extern IMethodSymbol SynthesizedIntrinsicOperatorSymbol(INamespaceOrTypeSymbol @leftType, String @name, INamespaceOrTypeSymbol @rightType, INamespaceOrTypeSymbol @returnType, Boolean @isCheckedBuiltin);
        public static extern IMethodSymbol SynthesizedIntrinsicOperatorSymbol(INamespaceOrTypeSymbol @container, String @name, INamespaceOrTypeSymbol @returnType, Boolean @isCheckedBuiltin);
        public static extern IFieldSymbol SynthesizedLambdaCacheFieldSymbol(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @type, String @name, IMethodSymbol @topLevelMethod, Boolean @isReadOnly, Boolean @isStatic);
        public static extern ILocalSymbol SynthesizedLocal(IMethodSymbol @containingMethodOpt, INamespaceOrTypeSymbol @type, Enum @kind, SyntaxNode @syntaxOpt, Boolean @isPinned = false, RefKind @refKind = None.None);
        public static extern IMethodSymbol SynthesizedStaticConstructor(INamespaceOrTypeSymbol @containingType);
        public static extern IMethodSymbol SynthesizedSubmissionConstructor(INamespaceOrTypeSymbol @containingType, Object @diagnostics);
        public static extern IMethodSymbol SynthesizedInteractiveInitializerMethod(INamespaceOrTypeSymbol @containingType, Object @diagnostics);
        public static extern INamespaceOrTypeSymbol SynthesizedSubstitutedTypeParameterSymbol(Object @owner, Object @map, INamespaceOrTypeSymbol @substitutedFrom, Int32 @ordinal);
        public static extern ILocalSymbol TypeSubstitutedLocalSymbol(ILocalSymbol @originalVariable, INamespaceOrTypeSymbol @type, Object @containingSymbol);
        public static extern INamespaceOrTypeSymbol UnsupportedMetadataTypeSymbol(BadImageFormatException @mrEx);
        public static extern IAssemblySymbol RetargetingAssemblySymbol(IAssemblySymbol @underlyingAssembly, Boolean @isLinked);
        public static extern IEventSymbol RetargetingEventSymbol(IModuleSymbol @retargetingModule, IEventSymbol @underlyingEvent);
        public static extern IFieldSymbol RetargetingFieldSymbol(IModuleSymbol @retargetingModule, IFieldSymbol @underlyingField);
        public static extern IMethodSymbol RetargetingMethodSymbol(IModuleSymbol @retargetingModule, IMethodSymbol @underlyingMethod);
        public static extern IModuleSymbol RetargetingModuleSymbol(IAssemblySymbol @retargetingAssembly, IModuleSymbol @underlyingModule);
        public static extern INamespaceOrTypeSymbol RetargetingNamedTypeSymbol(IModuleSymbol @retargetingModule, INamespaceOrTypeSymbol @underlyingType);
        public static extern INamespaceOrTypeSymbol RetargetingNamespaceSymbol(IModuleSymbol @retargetingModule, INamespaceOrTypeSymbol @underlyingNamespace);
        public static extern IParameterSymbol RetargetingMethodParameterSymbol(IMethodSymbol @retargetingMethod, IParameterSymbol @underlyingParameter);
        public static extern IParameterSymbol RetargetingPropertyParameterSymbol(IPropertySymbol @retargetingProperty, IParameterSymbol @underlyingParameter);
        public static extern IPropertySymbol RetargetingPropertySymbol(IModuleSymbol @retargetingModule, IPropertySymbol @underlyingProperty);
        public static extern INamespaceOrTypeSymbol RetargetingTypeParameterSymbol(IModuleSymbol @retargetingModule, INamespaceOrTypeSymbol @underlyingTypeParameter);
        public static extern IAssemblySymbol PEAssemblySymbol(Object @assembly, DocumentationProvider @documentationProvider, Boolean @isLinked, Enum @importOptions);
        public static extern IEventSymbol PEEventSymbol(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @containingType, EventDefinitionHandle @handle, IMethodSymbol @addMethod, IMethodSymbol @removeMethod, Object @privateFieldNameToSymbols);
        public static extern IFieldSymbol PEFieldSymbol(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @containingType, FieldDefinitionHandle @fieldDef);
        public static extern INamespaceOrTypeSymbol PEGlobalNamespaceSymbol(IModuleSymbol @moduleSymbol);
        public static extern IMethodSymbol PEMethodSymbol(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @containingType, MethodDefinitionHandle @methodDef);
        public static extern IModuleSymbol PEModuleSymbol(IAssemblySymbol @assemblySymbol, Object @module, Enum @importOptions, Int32 @ordinal);
        public static extern IModuleSymbol PEModuleSymbol(IAssemblySymbol @assemblySymbol, Object @module, Enum @importOptions, Int32 @ordinal);
        public static extern IModuleSymbol PEModuleSymbol(IAssemblySymbol @assemblySymbol, Object @module, Enum @importOptions, Int32 @ordinal);
        public static extern INamespaceOrTypeSymbol PENestedNamespaceSymbol(String @name, INamespaceOrTypeSymbol @containingNamespace, IEnumerable<IGrouping<String, TypeDefinitionHandle>> @typesByNS);
        public static extern INamespaceOrTypeSymbol PETypeParameterSymbol(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @definingNamedType, UInt16 @ordinal, GenericParameterHandle @handle);
        public static extern INamespaceOrTypeSymbol PETypeParameterSymbol(IModuleSymbol @moduleSymbol, IMethodSymbol @definingMethod, UInt16 @ordinal, GenericParameterHandle @handle);
        public static extern ILocalSymbol DummyLocal();
        public static extern IMethodSymbol AnonymousTypeConstructorSymbol(INamespaceOrTypeSymbol @container, ImmutableArray<AnonymousTypePropertySymbol> @properties);
        public static extern IMethodSymbol AnonymousTypePropertyGetAccessorSymbol(AnonymousTypePropertySymbol @property);
        public static extern IMethodSymbol AnonymousTypeEqualsMethodSymbol(INamespaceOrTypeSymbol @container);
        public static extern IMethodSymbol AnonymousTypeGetHashCodeMethodSymbol(INamespaceOrTypeSymbol @container);
        public static extern IMethodSymbol AnonymousTypeToStringMethodSymbol(INamespaceOrTypeSymbol @container);
        public static extern INamespaceOrTypeSymbol AnonymousTypePublicSymbol(Object @manager, ValueType @typeDescr);
        public static extern IFieldSymbol AnonymousTypeFieldSymbol(IPropertySymbol @property);
        public static extern IPropertySymbol AnonymousTypePropertySymbol(AnonymousTypeTemplateSymbol @container, ValueType @field, INamespaceOrTypeSymbol @fieldTypeSymbol);
        public static extern IPropertySymbol AnonymousTypePropertySymbol(AnonymousTypePublicSymbol @container, ValueType @field);
        public static extern INamespaceOrTypeSymbol AnonymousTypeTemplateSymbol(Object @manager, ValueType @typeDescr);
        public static extern INamespaceOrTypeSymbol AnonymousTypeParameterSymbol(Object @container, Int32 @ordinal, String @name);
        public static extern IMethodSymbol BaseMethodWrapperSymbol(INamespaceOrTypeSymbol @containingType, IMethodSymbol @methodBeingWrapped, SyntaxNode @syntax, String @name);
        public static extern INamespaceOrTypeSymbol SZArray(INamespaceOrTypeSymbol @elementType, INamespaceOrTypeSymbol @array, ImmutableArray<INamespaceOrTypeSymbol> @constructedInterfaces, ImmutableArray<CustomModifier> @customModifiers);
        public static extern INamespaceOrTypeSymbol MDArrayNoSizesOrBounds(INamespaceOrTypeSymbol @elementType, Int32 @rank, INamespaceOrTypeSymbol @array, ImmutableArray<CustomModifier> @customModifiers);
        public static extern INamespaceOrTypeSymbol MDArrayWithSizesAndBounds(INamespaceOrTypeSymbol @elementType, Int32 @rank, ImmutableArray<Int32> @sizes, ImmutableArray<Int32> @lowerBounds, INamespaceOrTypeSymbol @array, ImmutableArray<CustomModifier> @customModifiers);
        public static extern IFieldSymbol InferrableGlobalExpressionVariable(INamespaceOrTypeSymbol @containingType, Enum @modifiers, TypeSyntax @typeSyntax, String @name, SyntaxReference @syntax, Location @location, IFieldSymbol @containingFieldOpt, SyntaxNode @nodeToBind);
        public static extern IMethodSymbol SynthesizedEmbeddedAttributeConstructorSymbol(INamespaceOrTypeSymbol @containingType);
        public static extern INamespaceOrTypeSymbol ErrorTypeParameterSymbol(INamespaceOrTypeSymbol @container, String @name, Int32 @ordinal);
        public static extern INamespaceOrTypeSymbol TopLevel(IModuleSymbol @module, String @namespace, String @name, Int32 @arity, Boolean @mangleName);
        public static extern INamespaceOrTypeSymbol TopLevel(IModuleSymbol @module,  @fullName);
        public static extern INamespaceOrTypeSymbol TopLevel(IModuleSymbol @module,  @fullName, SpecialType @specialType);
        public static extern INamespaceOrTypeSymbol TopLevel(IModuleSymbol @module,  @fullName, Enum @wellKnownType);
        public static extern INamespaceOrTypeSymbol TopLevelWithCustomErrorInfo(IModuleSymbol @module,  @emittedName, Object @errorInfo);
        public static extern INamespaceOrTypeSymbol TopLevelWithCustomErrorInfo(IModuleSymbol @module,  @emittedName, Object @errorInfo, SpecialType @typeId);
        public static extern INamespaceOrTypeSymbol TopLevelWithCustomErrorInfo(IModuleSymbol @module,  @emittedName, Object @errorInfo, Enum @typeId);
        public static extern INamespaceOrTypeSymbol Nested(INamespaceOrTypeSymbol @containingType, String @name, Int32 @arity, Boolean @mangleName);
        public static extern INamespaceOrTypeSymbol Nested(INamespaceOrTypeSymbol @containingType,  @emittedName);
        public static extern IParameterSymbol ReducedExtensionMethodParameterSymbol(IMethodSymbol @containingMethod, IParameterSymbol @underlyingParameter);
        public static extern IMethodSymbol Constructor(INamespaceOrTypeSymbol @delegateType, INamespaceOrTypeSymbol @voidType, INamespaceOrTypeSymbol @objectType, INamespaceOrTypeSymbol @intPtrType, DelegateDeclarationSyntax @syntax);
        public static extern IMethodSymbol InvokeMethod(INamespaceOrTypeSymbol @delegateType, RefKind @refKind, INamespaceOrTypeSymbol @returnType, DelegateDeclarationSyntax @syntax, Object @binder, Object @diagnostics);
        public static extern IMethodSymbol BeginInvokeMethod(InvokeMethod @invoke, INamespaceOrTypeSymbol @iAsyncResultType, INamespaceOrTypeSymbol @objectType, INamespaceOrTypeSymbol @asyncCallbackType, DelegateDeclarationSyntax @syntax);
        public static extern IMethodSymbol EndInvokeMethod(InvokeMethod @invoke, INamespaceOrTypeSymbol @iAsyncResultType, DelegateDeclarationSyntax @syntax);
        public static extern IFieldSymbol ZeroValuedEnumConstantSymbol(INamespaceOrTypeSymbol @containingEnum, EnumMemberDeclarationSyntax @syntax, Object @diagnostics);
        public static extern IFieldSymbol ExplicitValuedEnumConstantSymbol(INamespaceOrTypeSymbol @containingEnum, EnumMemberDeclarationSyntax @syntax, EqualsValueClauseSyntax @initializer, Object @diagnostics);
        public static extern IFieldSymbol ImplicitValuedEnumConstantSymbol(INamespaceOrTypeSymbol @containingEnum, EnumMemberDeclarationSyntax @syntax, IFieldSymbol @otherConstant, UInt32 @otherConstantOffset, Object @diagnostics);
        public static extern ILocalSymbol LocalWithInitializer(Object @containingSymbol, Object @scopeBinder, TypeSyntax @typeSyntax, SyntaxToken @identifierToken, EqualsValueClauseSyntax @initializer, Object @initializerBinder, Enum @declarationKind);
        public static extern ILocalSymbol ForEachLocalSymbol(Object @containingSymbol, Object @scopeBinder, TypeSyntax @typeSyntax, SyntaxToken @identifierToken, ExpressionSyntax @collection, Enum @declarationKind);
        public static extern ILocalSymbol DeconstructionLocalSymbol(Object @containingSymbol, Object @scopeBinder, Object @nodeBinder, TypeSyntax @typeSyntax, SyntaxToken @identifierToken, Enum @declarationKind, SyntaxNode @deconstruction);
        public static extern ILocalSymbol LocalSymbolWithEnclosingContext(Object @containingSymbol, Object @scopeBinder, Object @nodeBinder, TypeSyntax @typeSyntax, SyntaxToken @identifierToken, Enum @declarationKind, SyntaxNode @nodeToBind, SyntaxNode @forbiddenZone);
        public static extern IMethodSymbol DelegateConstructor(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @objectType, INamespaceOrTypeSymbol @intPtrType);
        public static extern IMethodSymbol InvokeMethod(INamespaceOrTypeSymbol @containingType, ValueType @byRefParameters, INamespaceOrTypeSymbol @voidReturnTypeOpt);
        public static extern IMethodSymbol AsyncForwardEntryPoint(CSharpCompilation @compilation, INamespaceOrTypeSymbol @containingType, IMethodSymbol @userMain);
        public static extern IMethodSymbol ScriptEntryPoint(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @returnType, IMethodSymbol @getAwaiterMethod, IMethodSymbol @getResultMethod);
        public static extern IMethodSymbol SubmissionEntryPoint(INamespaceOrTypeSymbol @containingType, INamespaceOrTypeSymbol @returnType, INamespaceOrTypeSymbol @submissionArrayType);
        public static extern IParameterSymbol SynthesizedOperatorParameterSymbol(IMethodSymbol @container, INamespaceOrTypeSymbol @type, Int32 @ordinal, String @name);
        public static extern IParameterSymbol SynthesizedParameterSymbolWithCustomModifiers(IMethodSymbol @container, INamespaceOrTypeSymbol @type, Int32 @ordinal, RefKind @refKind, String @name, ImmutableArray<CustomModifier> @customModifiers, ImmutableArray<CustomModifier> @refCustomModifiers);
        public static extern INamespaceOrTypeSymbol PENamedTypeSymbolNonGeneric(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @container, TypeDefinitionHandle @handle, String @emittedNamespaceName,  @mangleName);
        public static extern INamespaceOrTypeSymbol PENamedTypeSymbolGeneric(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @container, TypeDefinitionHandle @handle, String @emittedNamespaceName, GenericParameterHandleCollection @genericParameterHandles, UInt16 @arity,  @mangleName);
        public static extern IParameterSymbol PEParameterSymbolWithCustomModifiers(IModuleSymbol @moduleSymbol, Object @containingSymbol, Int32 @ordinal, Boolean @isByRef, ImmutableArray<ValueType> @refCustomModifiers, INamespaceOrTypeSymbol @type, ParameterHandle @handle, ImmutableArray<ValueType> @customModifiers,  @isBad);
        public static extern IPropertySymbol PEPropertySymbolWithCustomModifiers(IModuleSymbol @moduleSymbol, INamespaceOrTypeSymbol @containingType, PropertyDefinitionHandle @handle, IMethodSymbol @getMethod, IMethodSymbol @setMethod, ParamInfo[] @propertyParams, Object @metadataDecoder);
        public static extern IHasArgumentsExpression BoundCall(SyntaxNode @syntax, Object @receiverOpt, IMethodSymbol @method, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Boolean @isDelegateCall, Boolean @expanded, Boolean @invokedAsExtensionMethod, ImmutableArray<Int32> @argsToParamsOpt, Enum @resultKind, Object @binderOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundTypeExpression(SyntaxNode @syntax, IAliasSymbol @aliasOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundTypeExpression(SyntaxNode @syntax, IAliasSymbol @aliasOpt, INamespaceOrTypeSymbol @type);
        public static extern Object BoundTypeExpression(SyntaxNode @syntax, IAliasSymbol @aliasOpt, Boolean @inferredType, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundTypeExpression(SyntaxNode @syntax, IAliasSymbol @aliasOpt, Boolean @inferredType, Object @boundContainingTypeOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundNamespaceExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @namespaceSymbol, Boolean @hasErrors = false);
        public static extern Object BoundNamespaceExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @namespaceSymbol);
        public static extern Object BoundNamespaceExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @namespaceSymbol, IAliasSymbol @aliasOpt, Boolean @hasErrors);
        public static extern Object BoundNamespaceExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @namespaceSymbol, IAliasSymbol @aliasOpt);
        public static extern ILocalReferenceExpression BoundLocal(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern ILocalReferenceExpression BoundLocal(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @constantValueOpt, INamespaceOrTypeSymbol @type);
        public static extern ILocalReferenceExpression BoundLocal(SyntaxNode @syntax, ILocalSymbol @localSymbol, Boolean @isDeclaration, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern ILocalReferenceExpression BoundLocal(SyntaxNode @syntax, ILocalSymbol @localSymbol, Boolean @isDeclaration, Object @constantValueOpt, INamespaceOrTypeSymbol @type);
        public static extern IMemberReferenceExpression BoundFieldAccess(SyntaxNode @syntax, Object @receiver, IFieldSymbol @fieldSymbol, Object @constantValueOpt, Boolean @hasErrors = false);
        public static extern IMemberReferenceExpression BoundFieldAccess(SyntaxNode @syntax, Object @receiver, IFieldSymbol @fieldSymbol, Object @constantValueOpt, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IMemberReferenceExpression BoundFieldAccess(SyntaxNode @syntax, Object @receiverOpt, IFieldSymbol @fieldSymbol, Object @constantValueOpt, Enum @resultKind, Boolean @isByValue, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IMemberReferenceExpression BoundPropertyAccess(SyntaxNode @syntax, Object @receiverOpt, IPropertySymbol @propertySymbol, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IMemberReferenceExpression BoundIndexerAccess(SyntaxNode @syntax, Object @receiverOpt, IPropertySymbol @indexer, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Boolean @expanded, ImmutableArray<Int32> @argsToParamsOpt, Object @binderOpt, Boolean @useSetterForDefaultArgumentGeneration, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDynamicIndexerAccess(SyntaxNode @syntax, Object @receiverOpt, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, ImmutableArray<IPropertySymbol> @applicableIndexers, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IMemberReferenceExpression BoundEventAccess(SyntaxNode @syntax, Object @receiverOpt, IEventSymbol @eventSymbol, Boolean @isUsableAsField, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IParameterReferenceExpression BoundParameter(SyntaxNode @syntax, IParameterSymbol @parameterSymbol, Boolean @hasErrors = false);
        public static extern IParameterReferenceExpression BoundParameter(SyntaxNode @syntax, IParameterSymbol @parameterSymbol);
        public static extern IParameterReferenceExpression BoundParameter(SyntaxNode @syntax, IParameterSymbol @parameterSymbol, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IParameterReferenceExpression BoundParameter(SyntaxNode @syntax, IParameterSymbol @parameterSymbol, INamespaceOrTypeSymbol @type);
        public static extern IHasOperatorMethodExpression BoundBinaryOperator(SyntaxNode @syntax, Enum @operatorKind, Object @left, Object @right, Object @constantValueOpt, IMethodSymbol @methodOpt, Enum @resultKind, ImmutableArray<IMethodSymbol> @originalUserDefinedOperatorsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasOperatorMethodExpression BoundBinaryOperator(SyntaxNode @syntax, Enum @operatorKind, Object @left, Object @right, Object @constantValueOpt, IMethodSymbol @methodOpt, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundUserDefinedConditionalLogicalOperator(SyntaxNode @syntax, Enum @operatorKind, Object @left, Object @right, IMethodSymbol @logicalOperator, IMethodSymbol @trueOperator, IMethodSymbol @falseOperator, Enum @resultKind, ImmutableArray<IMethodSymbol> @originalUserDefinedOperatorsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundUserDefinedConditionalLogicalOperator(SyntaxNode @syntax, Enum @operatorKind, Object @left, Object @right, IMethodSymbol @logicalOperator, IMethodSymbol @trueOperator, IMethodSymbol @falseOperator, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasOperatorMethodExpression BoundUnaryOperator(SyntaxNode @syntax, Enum @operatorKind, Object @operand, Object @constantValueOpt, IMethodSymbol @methodOpt, Enum @resultKind, ImmutableArray<IMethodSymbol> @originalUserDefinedOperatorsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasOperatorMethodExpression BoundUnaryOperator(SyntaxNode @syntax, Enum @operatorKind, Object @operand, Object @constantValueOpt, IMethodSymbol @methodOpt, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundIncrementOperator(SyntaxNode @syntax, Enum @operatorKind, Object @operand, IMethodSymbol @methodOpt, Conversion @operandConversion, Conversion @resultConversion, Enum @resultKind, ImmutableArray<IMethodSymbol> @originalUserDefinedOperatorsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundIncrementOperator(SyntaxNode @syntax, Enum @operatorKind, Object @operand, IMethodSymbol @methodOpt, Conversion @operandConversion, Conversion @resultConversion, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundCompoundAssignmentOperator(SyntaxNode @syntax, ValueType @operator, Object @left, Object @right, Conversion @leftConversion, Conversion @finalConversion, Enum @resultKind, ImmutableArray<IMethodSymbol> @originalUserDefinedOperatorsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundCompoundAssignmentOperator(SyntaxNode @syntax, ValueType @operator, Object @left, Object @right, Conversion @leftConversion, Conversion @finalConversion, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern ILiteralExpression BoundLiteral(SyntaxNode @syntax, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern ILiteralExpression BoundLiteral(SyntaxNode @syntax, Object @constantValueOpt, INamespaceOrTypeSymbol @type);
        public static extern IHasOperatorMethodExpression BoundConversion(SyntaxNode @syntax, Object @operand, Conversion @conversion, Boolean @checked, Boolean @explicitCastInCode, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasOperatorMethodExpression BoundConversion(SyntaxNode @syntax, Object @operand, Conversion @conversion, Boolean @isBaseConversion, Boolean @checked, Boolean @explicitCastInCode, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasArgumentsExpression BoundObjectCreationExpression(SyntaxNode @syntax, IMethodSymbol @constructor, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Boolean @expanded, ImmutableArray<Int32> @argsToParamsOpt, Object @constantValueOpt, Object @initializerExpressionOpt, Object @binderOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IHasArgumentsExpression BoundObjectCreationExpression(SyntaxNode @syntax, IMethodSymbol @constructor, Object @binderOpt, BoundExpression[][] @arguments);
        public static extern IHasArgumentsExpression BoundObjectCreationExpression(SyntaxNode @syntax, IMethodSymbol @constructor, Object @binderOpt, ImmutableArray<Object> @arguments);
        public static extern IHasArgumentsExpression BoundObjectCreationExpression(SyntaxNode @syntax, IMethodSymbol @constructor, ImmutableArray<IMethodSymbol> @constructorsGroup, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Boolean @expanded, ImmutableArray<Int32> @argsToParamsOpt, Object @constantValueOpt, Object @initializerExpressionOpt, Object @binderOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundAnonymousObjectCreationExpression(SyntaxNode @syntax, IMethodSymbol @constructor, ImmutableArray<Object> @arguments, ImmutableArray<Object> @declarations, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundAnonymousPropertyDeclaration(SyntaxNode @syntax, IPropertySymbol @property, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundAnonymousPropertyDeclaration(SyntaxNode @syntax, IPropertySymbol @property, INamespaceOrTypeSymbol @type);
        public static extern ILambdaExpression BoundLambda(SyntaxNode @syntax, IBlockStatement @body, ImmutableArray<Diagnostic> @diagnostics, Object @binder, INamespaceOrTypeSymbol @delegateType, Boolean @inferReturnType);
        public static extern ILambdaExpression BoundLambda(SyntaxNode @syntax, IMethodSymbol @symbol, IBlockStatement @body, ImmutableArray<Diagnostic> @diagnostics, Object @binder, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundAttribute(SyntaxNode @syntax, IMethodSymbol @constructor, ImmutableArray<Object> @constructorArguments, ImmutableArray<String> @constructorArgumentNamesOpt, ImmutableArray<Object> @namedArguments, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IDefaultValueExpression BoundDefaultExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IDefaultValueExpression BoundDefaultExpression(SyntaxNode @syntax, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IDefaultValueExpression BoundDefaultExpression(SyntaxNode @syntax, Object @constantValueOpt, INamespaceOrTypeSymbol @type);
        public static extern IConditionalChoiceExpression BoundConditionalOperator(SyntaxNode @syntax, Boolean @isByRef, Object @condition, Object @consequence, Object @alternative, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern ITypeOperationExpression BoundSizeOfOperator(SyntaxNode @syntax, Object @sourceType, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundRangeVariable(SyntaxNode @syntax, IRangeVariableSymbol @rangeVariableSymbol, Object @value, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundLabel(SyntaxNode @syntax, ILabelSymbol @label, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundLabel(SyntaxNode @syntax, ILabelSymbol @label, INamespaceOrTypeSymbol @type);
        public static extern Object BoundObjectInitializerMember(SyntaxNode @syntax, Object @memberSymbol, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Boolean @expanded, ImmutableArray<Int32> @argsToParamsOpt, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAwaitExpression BoundAwaitExpression(SyntaxNode @syntax, Object @expression, IMethodSymbol @getAwaiter, IPropertySymbol @isCompleted, IMethodSymbol @getResult, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundCollectionElementInitializer(SyntaxNode @syntax, IMethodSymbol @addMethod, ImmutableArray<Object> @arguments, Boolean @expanded, ImmutableArray<Int32> @argsToParamsOpt, Boolean @invokedAsExtensionMethod, Enum @resultKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IInstanceReferenceExpression BoundBaseReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IInstanceReferenceExpression BoundBaseReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundNameOfOperator(SyntaxNode @syntax, Object @argument, Object @constantValueOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundMethodGroup(SyntaxNode @syntax, ImmutableArray<INamespaceOrTypeSymbol> @typeArgumentsOpt, Object @receiverOpt, String @name, ImmutableArray<IMethodSymbol> @methods, Object @lookupResult, Enum @flags, Boolean @hasErrors = false);
        public static extern Object BoundMethodGroup(SyntaxNode @syntax, ImmutableArray<INamespaceOrTypeSymbol> @typeArgumentsOpt, String @name, ImmutableArray<IMethodSymbol> @methods, Object @lookupSymbolOpt, Object @lookupError, Enum @flags, Object @receiverOpt, Enum @resultKind, Boolean @hasErrors = false);
        public static extern Object BoundQueryClause(SyntaxNode @syntax, Object @value, IRangeVariableSymbol @definedSymbol, Object @queryInvocation, Object @castInvocation, Object @binder, Object @unoptimizedForm, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundQueryClause(SyntaxNode @syntax, Object @value, IRangeVariableSymbol @definedSymbol, Object @binder, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundSequencePoint(SyntaxNode @syntax, Object @statementOpt, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundAssignmentOperator(SyntaxNode @syntax, Object @left, Object @right, INamespaceOrTypeSymbol @type, RefKind @refKind = None.None, Boolean @hasErrors = false);
        public static extern IAssignmentExpression BoundAssignmentOperator(SyntaxNode @syntax, Object @left, Object @right, RefKind @refKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IInvalidExpression BoundBadExpression(SyntaxNode @syntax, Enum @resultKind, ImmutableArray<Object> @symbols, ImmutableArray<Object> @childBoundNodes, INamespaceOrTypeSymbol @type);
        public static extern IInvalidExpression BoundBadExpression(SyntaxNode @syntax, Enum @resultKind, ImmutableArray<Object> @symbols, ImmutableArray<Object> @childBoundNodes, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundStatementList(Enum @kind, SyntaxNode @syntax, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern Object BoundStatementList(SyntaxNode @syntax, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern IReturnStatement BoundReturnStatement(SyntaxNode @syntax, RefKind @refKind, Object @expressionOpt, Boolean @hasErrors = false);
        public static extern IReturnStatement BoundYieldBreakStatement(SyntaxNode @syntax, Boolean @hasErrors);
        public static extern IReturnStatement BoundYieldBreakStatement(SyntaxNode @syntax);
        public static extern IBranchStatement BoundGotoStatement(SyntaxNode @syntax, ILabelSymbol @label, Boolean @hasErrors = false);
        public static extern IBranchStatement BoundGotoStatement(SyntaxNode @syntax, ILabelSymbol @label, Object @caseExpressionOpt, Object @labelExpressionOpt, Boolean @hasErrors = false);
        public static extern IBlockStatement BoundBlock(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern IBlockStatement BoundBlock(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, ImmutableArray<IMethodSymbol> @localFunctions, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern ITryStatement BoundTryStatement(SyntaxNode @syntax, IBlockStatement @tryBlock, ImmutableArray<ICatchClause> @catchBlocks, IBlockStatement @finallyBlockOpt);
        public static extern ITryStatement BoundTryStatement(SyntaxNode @syntax, IBlockStatement @tryBlock, ImmutableArray<ICatchClause> @catchBlocks, IBlockStatement @finallyBlockOpt, Boolean @preferFaultHandler, Boolean @hasErrors = false);
        public static extern IPlaceholderExpression BoundDeconstructValuePlaceholder(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IPlaceholderExpression BoundDeconstructValuePlaceholder(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern IEventAssignmentExpression BoundEventAssignmentOperator(SyntaxNode @syntax, IEventSymbol @event, Boolean @isAddition, Boolean @isDynamic, Object @receiverOpt, Object @argument, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDelegateCreationExpression(SyntaxNode @syntax, Object @argument, IMethodSymbol @methodOpt, Boolean @isExtensionMethod, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IUnboundLambdaExpression UnboundLambda(CSharpSyntaxNode @syntax, Object @binder, ImmutableArray<RefKind> @refKinds, ImmutableArray<INamespaceOrTypeSymbol> @types, ImmutableArray<String> @names, Boolean @isAsync, Boolean @hasErrors = false);
        public static extern IUnboundLambdaExpression UnboundLambda(SyntaxNode @syntax, Object @data, Boolean @hasErrors);
        public static extern IUnboundLambdaExpression UnboundLambda(SyntaxNode @syntax, Object @data);
        public static extern IHasOperatorMethodExpression BoundAsOperator(SyntaxNode @syntax, Object @operand, Object @targetType, Conversion @conversion, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IIsTypeExpression BoundIsOperator(SyntaxNode @syntax, Object @operand, Object @targetType, Conversion @conversion, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern ITypeOperationExpression BoundTypeOfOperator(SyntaxNode @syntax, Object @sourceType, IMethodSymbol @getTypeFromHandle, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IArrayCreationExpression BoundArrayCreation(SyntaxNode @syntax, ImmutableArray<Object> @bounds, IArrayInitializer @initializerOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IArrayInitializer BoundArrayInitialization(SyntaxNode @syntax, ImmutableArray<Object> @initializers, Boolean @hasErrors = false);
        public static extern Object BoundDup(SyntaxNode @syntax, RefKind @refKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundDup(SyntaxNode @syntax, RefKind @refKind, INamespaceOrTypeSymbol @type);
        public static extern IInstanceReferenceExpression BoundThisReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IInstanceReferenceExpression BoundThisReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundDeconstructionAssignmentOperator(SyntaxNode @syntax, Object @left, IHasOperatorMethodExpression @right, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern ITypeParameterObjectCreationExpression BoundNewT(SyntaxNode @syntax, Object @initializerExpressionOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern INullCoalescingExpression BoundNullCoalescingOperator(SyntaxNode @syntax, Object @leftOperand, Object @rightOperand, Conversion @leftConversion, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IArrayElementReferenceExpression BoundArrayAccess(SyntaxNode @syntax, Object @expression, ImmutableArray<Object> @indices, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IPointerIndirectionReferenceExpression BoundPointerIndirectionOperator(SyntaxNode @syntax, Object @operand, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IAddressOfExpression BoundAddressOfOperator(SyntaxNode @syntax, Object @operand, Boolean @isFixedStatementAddressOf, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IInstanceReferenceExpression BoundImplicitReceiver(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IInstanceReferenceExpression BoundImplicitReceiver(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern IConditionalAccessExpression BoundConditionalAccess(SyntaxNode @syntax, Object @receiver, Object @accessExpression, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern IConditionalAccessInstanceExpression BoundConditionalReceiver(SyntaxNode @syntax, Int32 @id, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern IConditionalAccessInstanceExpression BoundConditionalReceiver(SyntaxNode @syntax, Int32 @id, INamespaceOrTypeSymbol @type);
        public static extern ISymbolInitializer BoundFieldEqualsValue(SyntaxNode @syntax, IFieldSymbol @field, Object @value, Boolean @hasErrors = false);
        public static extern ISymbolInitializer BoundPropertyEqualsValue(SyntaxNode @syntax, IPropertySymbol @property, Object @value, Boolean @hasErrors = false);
        public static extern ISymbolInitializer BoundParameterEqualsValue(SyntaxNode @syntax, IParameterSymbol @parameter, Object @value, Boolean @hasErrors = false);
        public static extern Object BoundDeclarationPattern(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @declaredType, Boolean @isVar, Boolean @hasErrors = false);
        public static extern Object BoundDeclarationPattern(SyntaxNode @syntax, Object @variable, Object @variableAccess, Object @declaredType, Boolean @isVar, Boolean @hasErrors = false);
        public static extern Object BoundConstantPattern(SyntaxNode @syntax, Object @value, Object @constantValue, Boolean @hasErrors = false);
        public static extern Object BoundWildcardPattern(SyntaxNode @syntax, Boolean @hasErrors);
        public static extern Object BoundWildcardPattern(SyntaxNode @syntax);
        public static extern Object BoundArgListOperator(SyntaxNode @syntax, ImmutableArray<Object> @arguments, ImmutableArray<RefKind> @argumentRefKindsOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundPropertyGroup(SyntaxNode @syntax, ImmutableArray<IPropertySymbol> @properties, Object @receiverOpt, Enum @resultKind, Boolean @hasErrors = false);
        public static extern Object BoundSequencePointExpression(SyntaxNode @syntax, Object @expression, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundSequence(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, ImmutableArray<Object> @sideEffects, Object @value, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundPreviousSubmissionReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundPreviousSubmissionReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundHostObjectMemberReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundHostObjectMemberReference(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundTypeOrValueExpression(SyntaxNode @syntax, ValueType @data, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundTypeOrValueExpression(SyntaxNode @syntax, ValueType @data, INamespaceOrTypeSymbol @type);
        public static extern Object BoundPseudoVariable(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @emitExpressions, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundPseudoVariable(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @emitExpressions, INamespaceOrTypeSymbol @type);
        public static extern Object BoundPointerElementAccess(SyntaxNode @syntax, Object @expression, Object @index, Boolean @checked, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundRefTypeOperator(SyntaxNode @syntax, Object @operand, IMethodSymbol @getTypeFromHandle, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDynamicMemberAccess(SyntaxNode @syntax, Object @receiver, ImmutableArray<INamespaceOrTypeSymbol> @typeArgumentsOpt, String @name, Boolean @invoked, Boolean @indexed, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundMakeRefOperator(SyntaxNode @syntax, Object @operand, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundRefValueOperator(SyntaxNode @syntax, Object @operand, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDynamicInvocation(SyntaxNode @syntax, Object @expression, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, ImmutableArray<IMethodSymbol> @applicableMethods, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundArrayLength(SyntaxNode @syntax, Object @expression, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundMethodDefIndex(SyntaxNode @syntax, IMethodSymbol @method, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundMethodDefIndex(SyntaxNode @syntax, IMethodSymbol @method, INamespaceOrTypeSymbol @type);
        public static extern Object BoundModuleVersionId(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundModuleVersionId(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundModuleVersionIdString(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundModuleVersionIdString(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundInstrumentationPayloadRoot(SyntaxNode @syntax, Int32 @analysisKind, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundInstrumentationPayloadRoot(SyntaxNode @syntax, Int32 @analysisKind, INamespaceOrTypeSymbol @type);
        public static extern Object BoundMaximumMethodDefIndex(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundMaximumMethodDefIndex(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundSourceDocumentIndex(SyntaxNode @syntax, Object @document, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundSourceDocumentIndex(SyntaxNode @syntax, Object @document, INamespaceOrTypeSymbol @type);
        public static extern Object BoundMethodInfo(SyntaxNode @syntax, IMethodSymbol @method, IMethodSymbol @getMethodFromHandle, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundMethodInfo(SyntaxNode @syntax, IMethodSymbol @method, IMethodSymbol @getMethodFromHandle, INamespaceOrTypeSymbol @type);
        public static extern Object BoundCollectionInitializerExpression(SyntaxNode @syntax, ImmutableArray<Object> @initializers, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundFieldInfo(SyntaxNode @syntax, IFieldSymbol @field, IMethodSymbol @getFieldFromHandle, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundFieldInfo(SyntaxNode @syntax, IFieldSymbol @field, IMethodSymbol @getFieldFromHandle, INamespaceOrTypeSymbol @type);
        public static extern Object BoundLoweredConditionalAccess(SyntaxNode @syntax, Object @receiver, IMethodSymbol @hasValueMethodOpt, Object @whenNotNull, Object @whenNullOpt, Int32 @id, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundArgList(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundArgList(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object BoundDynamicCollectionElementInitializer(SyntaxNode @syntax, ImmutableArray<Object> @arguments, ImmutableArray<IMethodSymbol> @applicableMethods, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundComplexConditionalReceiver(SyntaxNode @syntax, Object @valueTypeReceiver, Object @referenceTypeReceiver, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundFixedLocalCollectionInitializer(SyntaxNode @syntax, INamespaceOrTypeSymbol @elementPointerType, Conversion @elementPointerTypeConversion, Object @expression, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundStackAllocArrayCreation(SyntaxNode @syntax, Object @count, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDynamicObjectCreationExpression(SyntaxNode @syntax, ImmutableArray<Object> @arguments, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<RefKind> @argumentRefKindsOpt, Object @initializerExpressionOpt, ImmutableArray<IMethodSymbol> @applicableMethods, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundHoistedFieldAccess(SyntaxNode @syntax, IFieldSymbol @fieldSymbol, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundHoistedFieldAccess(SyntaxNode @syntax, IFieldSymbol @fieldSymbol, INamespaceOrTypeSymbol @type);
        public static extern Object BoundInterpolatedString(SyntaxNode @syntax, ImmutableArray<Object> @parts, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundNoPiaObjectCreationExpression(SyntaxNode @syntax, String @guidString, Object @initializerExpressionOpt, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundObjectInitializerExpression(SyntaxNode @syntax, ImmutableArray<Object> @initializers, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundStringInsert(SyntaxNode @syntax, Object @value, Object @alignment, Object @format, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDynamicObjectInitializerMember(SyntaxNode @syntax, String @memberName, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundDynamicObjectInitializerMember(SyntaxNode @syntax, String @memberName, INamespaceOrTypeSymbol @type);
        public static extern Object OutDeconstructVarPendingInference(SyntaxNode @syntax, Boolean @hasErrors);
        public static extern Object OutDeconstructVarPendingInference(SyntaxNode @syntax);
        public static extern Object BoundIsPatternExpression(SyntaxNode @syntax, Object @expression, Object @pattern, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundThrowExpression(SyntaxNode @syntax, Object @expression, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundDiscardExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @type, Boolean @hasErrors);
        public static extern Object BoundDiscardExpression(SyntaxNode @syntax, INamespaceOrTypeSymbol @type);
        public static extern Object DeconstructionVariablePendingInference(SyntaxNode @syntax, Object @variableSymbol, Object @receiverOpt, Boolean @hasErrors = false);
        public static extern Object OutVariablePendingInference(SyntaxNode @syntax, Object @variableSymbol, Object @receiverOpt, Boolean @hasErrors = false);
        public static extern IBranchStatement BoundContinueStatement(SyntaxNode @syntax, ILabelSymbol @label, Boolean @hasErrors);
        public static extern IBranchStatement BoundContinueStatement(SyntaxNode @syntax, ILabelSymbol @label);
        public static extern IBranchStatement BoundBreakStatement(SyntaxNode @syntax, ILabelSymbol @label, Boolean @hasErrors);
        public static extern IBranchStatement BoundBreakStatement(SyntaxNode @syntax, ILabelSymbol @label);
        public static extern IEmptyStatement BoundNoOpStatement(SyntaxNode @syntax, Enum @flavor, Boolean @hasErrors);
        public static extern IEmptyStatement BoundNoOpStatement(SyntaxNode @syntax, Enum @flavor);
        public static extern IIfStatement BoundIfStatement(SyntaxNode @syntax, Object @condition, Object @consequence, Object @alternativeOpt, Boolean @hasErrors = false);
        public static extern ILoopStatement BoundWhileStatement(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, Object @condition, Object @body, ILabelSymbol @breakLabel, ILabelSymbol @continueLabel, Boolean @hasErrors = false);
        public static extern ILoopStatement BoundDoStatement(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, Object @condition, Object @body, ILabelSymbol @breakLabel, ILabelSymbol @continueLabel, Boolean @hasErrors = false);
        public static extern ILoopStatement BoundForStatement(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @outerLocals, Object @initializer, ImmutableArray<ILocalSymbol> @innerLocals, Object @condition, Object @increment, Object @body, ILabelSymbol @breakLabel, ILabelSymbol @continueLabel, Boolean @hasErrors = false);
        public static extern ILoopStatement BoundForEachStatement(SyntaxNode @syntax, Object @enumeratorInfoOpt, Conversion @elementConversion, Object @iterationVariableType, ImmutableArray<ILocalSymbol> @iterationVariables, Object @expression, Object @deconstructionOpt, Object @body, Boolean @checked, ILabelSymbol @breakLabel, ILabelSymbol @continueLabel, Boolean @hasErrors = false);
        public static extern ISwitchStatement BoundSwitchStatement(SyntaxNode @syntax, Object @loweredPreambleOpt, Object @expression, ILabelSymbol @constantTargetOpt, ImmutableArray<ILocalSymbol> @innerLocals, ImmutableArray<IMethodSymbol> @innerLocalFunctions, ImmutableArray<Object> @switchSections, ILabelSymbol @breakLabel, IMethodSymbol @stringEquality, Boolean @hasErrors = false);
        public static extern ICaseClause BoundSwitchLabel(SyntaxNode @syntax, ILabelSymbol @label, Object @expressionOpt, Object @constantValueOpt, Boolean @hasErrors = false);
        public static extern ICatchClause BoundCatchBlock(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, Object @exceptionSourceOpt, INamespaceOrTypeSymbol @exceptionTypeOpt, Object @exceptionFilterOpt, IBlockStatement @body, Boolean @isSynthesizedAsyncCatchAll, Boolean @hasErrors = false);
        public static extern IFixedStatement BoundFixedStatement(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, IVariableDeclarationStatement @declarations, Object @body, Boolean @hasErrors = false);
        public static extern IUsingStatement BoundUsingStatement(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, IVariableDeclarationStatement @declarationsOpt, Object @expressionOpt, Conversion @iDisposableConversion, Object @body, Boolean @hasErrors = false);
        public static extern IThrowStatement BoundThrowStatement(SyntaxNode @syntax, Object @expressionOpt, Boolean @hasErrors = false);
        public static extern IReturnStatement BoundYieldReturnStatement(SyntaxNode @syntax, Object @expression, Boolean @hasErrors = false);
        public static extern ILockStatement BoundLockStatement(SyntaxNode @syntax, Object @argument, Object @body, Boolean @hasErrors = false);
        public static extern IInvalidStatement BoundBadStatement(SyntaxNode @syntax, ImmutableArray<Object> @childBoundNodes, Boolean @hasErrors = false);
        public static extern IVariableDeclarationStatement BoundLocalDeclaration(SyntaxNode @syntax, ILocalSymbol @localSymbol, Object @declaredType, Object @initializerOpt, ImmutableArray<Object> @argumentsOpt, Boolean @hasErrors = false);
        public static extern IVariableDeclarationStatement BoundMultipleLocalDeclarations(SyntaxNode @syntax, ImmutableArray<IVariableDeclarationStatement> @localDeclarations, Boolean @hasErrors = false);
        public static extern ILabelStatement BoundLabelStatement(SyntaxNode @syntax, ILabelSymbol @label, Boolean @hasErrors);
        public static extern ILabelStatement BoundLabelStatement(SyntaxNode @syntax, ILabelSymbol @label);
        public static extern ILabelStatement BoundLabeledStatement(SyntaxNode @syntax, ILabelSymbol @label, Object @body, Boolean @hasErrors = false);
        public static extern IExpressionStatement BoundExpressionStatement(SyntaxNode @syntax, Object @expression, Boolean @hasErrors = false);
        public static extern Object BoundSwitchSection(SyntaxNode @syntax, ImmutableArray<ICaseClause> @switchLabels, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern Object BoundConditionalGoto(SyntaxNode @syntax, Object @condition, Boolean @jumpIfTrue, ILabelSymbol @label, Boolean @hasErrors = false);
        public static extern Object BoundSequencePointWithSpan(SyntaxNode @syntax, Object @statementOpt, TextSpan @span, Boolean @hasErrors = false);
        public static extern Object BoundStateMachineScope(SyntaxNode @syntax, ImmutableArray<IFieldSymbol> @fields, Object @statement, Boolean @hasErrors = false);
        public static extern Object BoundLocalFunctionStatement(SyntaxNode @syntax, IMethodSymbol @symbol, IBlockStatement @body, Boolean @hasErrors = false);
        public static extern Object BoundPatternSwitchStatement(SyntaxNode @syntax, Object @expression, ImmutableArray<ILocalSymbol> @innerLocals, ImmutableArray<IMethodSymbol> @innerLocalFunctions, ImmutableArray<Object> @switchSections, Object @defaultLabel, ILabelSymbol @breakLabel, Object @binder, Boolean @isComplete, Boolean @hasErrors = false);
        public static extern Object BoundPatternSwitchSection(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, ImmutableArray<Object> @switchLabels, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern Object BoundPatternSwitchLabel(SyntaxNode @syntax, ILabelSymbol @label, Object @pattern, Object @guard, Boolean @isReachable, Boolean @hasErrors = false);
        public static extern Object PartiallyLoweredLocalFunctionReference(Object @underlying, Dictionary<Object, Object> @proxies);
        public static extern Object BoundFieldInitializer(SyntaxNode @syntax, IFieldSymbol @field, Object @initialValue, Boolean @hasErrors = false);
        public static extern Object BoundGlobalStatementInitializer(SyntaxNode @syntax, Object @statement, Boolean @hasErrors = false);
        public static extern Object BoundScope(SyntaxNode @syntax, ImmutableArray<ILocalSymbol> @locals, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern Object BoundForEachDeconstructStep(SyntaxNode @syntax, Object @deconstructionAssignment, IPlaceholderExpression @targetPlaceholder, Boolean @hasErrors = false);
        public static extern Object BoundTupleLiteral(SyntaxNode @syntax, ImmutableArray<String> @argumentNamesOpt, ImmutableArray<Boolean> @inferredNamesOpt, ImmutableArray<Object> @arguments, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundConvertedTupleLiteral(SyntaxNode @syntax, INamespaceOrTypeSymbol @naturalTypeOpt, ImmutableArray<Object> @arguments, INamespaceOrTypeSymbol @type, Boolean @hasErrors = false);
        public static extern Object BoundTypeOrInstanceInitializers(SyntaxNode @syntax, ImmutableArray<Object> @statements, Boolean @hasErrors = false);
        public static extern ISymbolInitializer FieldInitializer(SyntaxNode @syntax, IFieldSymbol @initializedField, IOperation @value);
        public static extern ISymbolInitializer PropertyInitializer(SyntaxNode @syntax, IPropertySymbol @initializedProperty, IOperation @value);
        public static extern ISwitchCase SwitchSection(Object @boundNode);
        public static extern Object BoundSpillSequenceBuilder(Object @value);
    }
}
