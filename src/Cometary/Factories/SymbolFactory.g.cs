using System;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Semantics;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cometary
{
    partial class SymbolFactory
    {
        public IBlockStatement BindExpressionBodyAsBlock(ArrowExpressionClauseSyntax expressionBody, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(BindExpressionBodyAsBlock), expressionBody, diagnostics);
        public IBlockStatement BindLambdaExpressionAsBlock(ExpressionSyntax body, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(BindLambdaExpressionAsBlock), body, diagnostics);
        public Byte GetRequiredReturnValueKind(Byte refKind) => (Byte)proxy.Invoke(nameof(GetRequiredReturnValueKind), refKind);
        public ITypeSymbol BindType(TypeSyntax syntax, Object diagnostics, Object isVar) => (ITypeSymbol)proxy.Invoke(nameof(BindType), syntax, diagnostics, isVar);
        public ITypeSymbol BindType(TypeSyntax syntax, Object diagnostics, Object isVar, Object alias) => (ITypeSymbol)proxy.Invoke(nameof(BindType), syntax, diagnostics, isVar, alias);
        public ISymbol BindTypeOrAlias(TypeSyntax syntax, Object diagnostics, Object isVar) => (ISymbol)proxy.Invoke(nameof(BindTypeOrAlias), syntax, diagnostics, isVar);
        public ITypeSymbol BindType(ExpressionSyntax syntax, Object diagnostics, Object basesBeingResolved = null) => (ITypeSymbol)proxy.Invoke(nameof(BindType), syntax, diagnostics, basesBeingResolved);
        public ITypeSymbol BindType(ExpressionSyntax syntax, Object diagnostics, Object alias, Object basesBeingResolved = null) => (ITypeSymbol)proxy.Invoke(nameof(BindType), syntax, diagnostics, alias, basesBeingResolved);
        public ISymbol BindTypeOrAlias(ExpressionSyntax syntax, Object diagnostics, Object basesBeingResolved = null) => (ISymbol)proxy.Invoke(nameof(BindTypeOrAlias), syntax, diagnostics, basesBeingResolved);
        public INamespaceOrTypeSymbol GetContainingNamespaceOrType(ISymbol symbol) => (INamespaceOrTypeSymbol)proxy.Invoke(nameof(GetContainingNamespaceOrType), symbol);
        public ISymbol BindNamespaceAliasSymbol(IdentifierNameSyntax node, Object diagnostics) => (ISymbol)proxy.Invoke(nameof(BindNamespaceAliasSymbol), node, diagnostics);
        public INamespaceOrTypeSymbol BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, Object diagnostics, Object basesBeingResolved = null) => (INamespaceOrTypeSymbol)proxy.Invoke(nameof(BindNamespaceOrTypeSymbol), syntax, diagnostics, basesBeingResolved);
        public INamespaceOrTypeSymbol BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, Object diagnostics, Object basesBeingResolved, Boolean suppressUseSiteDiagnostics) => (INamespaceOrTypeSymbol)proxy.Invoke(nameof(BindNamespaceOrTypeSymbol), syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);
        public ISymbol BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax, Object diagnostics, Object basesBeingResolved, Boolean suppressUseSiteDiagnostics) => (ISymbol)proxy.Invoke(nameof(BindNamespaceOrTypeOrAliasSymbol), syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);
        public ITypeSymbol BindTupleType(TupleTypeSyntax syntax, Object diagnostics) => (ITypeSymbol)proxy.Invoke(nameof(BindTupleType), syntax, diagnostics);
        public ISymbol BindPredefinedTypeSymbol(PredefinedTypeSyntax node, Object diagnostics) => (ISymbol)proxy.Invoke(nameof(BindPredefinedTypeSymbol), node, diagnostics);
        public ISymbol BindSimpleNamespaceOrTypeOrAliasSymbol(SimpleNameSyntax syntax, Object diagnostics, Object basesBeingResolved, Boolean suppressUseSiteDiagnostics, INamespaceOrTypeSymbol qualifierOpt = null) => (ISymbol)proxy.Invoke(nameof(BindSimpleNamespaceOrTypeOrAliasSymbol), syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt);
        public ISymbol BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(IdentifierNameSyntax node, Object diagnostics, Object basesBeingResolved, Boolean suppressUseSiteDiagnostics, INamespaceOrTypeSymbol qualifierOpt, Boolean isNameofArgument = false, Object symbols = null) => (ISymbol)proxy.Invoke(nameof(BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol), node, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt, isNameofArgument, symbols);
        public void ReportUseSiteDiagnosticForDynamic(Object diagnostics, IdentifierNameSyntax node) => proxy.Invoke(nameof(ReportUseSiteDiagnosticForDynamic), diagnostics, node);
        public ISymbol UnwrapAlias(ISymbol symbol, Object diagnostics, SyntaxNode syntax, Object basesBeingResolved = null) => (ISymbol)proxy.Invoke(nameof(UnwrapAlias), symbol, diagnostics, syntax, basesBeingResolved);
        public ISymbol UnwrapAlias(ISymbol symbol, Object alias, Object diagnostics, SyntaxNode syntax, Object basesBeingResolved = null) => (ISymbol)proxy.Invoke(nameof(UnwrapAlias), symbol, alias, diagnostics, syntax, basesBeingResolved);
        public INamedTypeSymbol BindGenericSimpleNamespaceOrTypeOrAliasSymbol(GenericNameSyntax node, Object diagnostics, Object basesBeingResolved, INamespaceOrTypeSymbol qualifierOpt) => (INamedTypeSymbol)proxy.Invoke(nameof(BindGenericSimpleNamespaceOrTypeOrAliasSymbol), node, diagnostics, basesBeingResolved, qualifierOpt);
        public INamedTypeSymbol LookupGenericTypeName(Object diagnostics, Object basesBeingResolved, INamespaceOrTypeSymbol qualifierOpt, GenericNameSyntax node, String plainName, Int32 arity, Int32 options) => (INamedTypeSymbol)proxy.Invoke(nameof(LookupGenericTypeName), diagnostics, basesBeingResolved, qualifierOpt, node, plainName, arity, options);
        public IErrorTypeSymbol CreateErrorIfLookupOnTypeParameter(CSharpSyntaxNode node, INamespaceOrTypeSymbol qualifierOpt, String name, Int32 arity, Object diagnostics) => (IErrorTypeSymbol)proxy.Invoke(nameof(CreateErrorIfLookupOnTypeParameter), node, qualifierOpt, name, arity, diagnostics);
        public ImmutableArray<INamespaceOrTypeSymbol> BindTypeArguments(SeparatedSyntaxList<TypeSyntax> typeArguments, Object diagnostics, Object basesBeingResolved = null) => (ImmutableArray<INamespaceOrTypeSymbol>)proxy.Invoke(nameof(BindTypeArguments), typeArguments, diagnostics, basesBeingResolved);
        public ITypeSymbol BindTypeArgument(TypeSyntax typeArgument, Object diagnostics, Object basesBeingResolved = null) => (ITypeSymbol)proxy.Invoke(nameof(BindTypeArgument), typeArgument, diagnostics, basesBeingResolved);
        public INamedTypeSymbol ConstructNamedTypeUnlessTypeArgumentOmitted(SyntaxNode typeSyntax, INamedTypeSymbol type, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Object diagnostics) => (INamedTypeSymbol)proxy.Invoke(nameof(ConstructNamedTypeUnlessTypeArgumentOmitted), typeSyntax, type, typeArgumentsSyntax, typeArguments, diagnostics);
        public INamedTypeSymbol ConstructNamedType(INamedTypeSymbol type, SyntaxNode typeSyntax, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Object basesBeingResolved, Object diagnostics) => (INamedTypeSymbol)proxy.Invoke(nameof(ConstructNamedType), type, typeSyntax, typeArgumentsSyntax, typeArguments, basesBeingResolved, diagnostics);
        public INamespaceOrTypeSymbol BindQualifiedName(ExpressionSyntax leftName, SimpleNameSyntax rightName, Object diagnostics, Object basesBeingResolved, Boolean suppressUseSiteDiagnostics) => (INamespaceOrTypeSymbol)proxy.Invoke(nameof(BindQualifiedName), leftName, rightName, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);
        public INamedTypeSymbol GetSpecialType(SByte typeId, Object diagnostics, SyntaxNode node) => (INamedTypeSymbol)proxy.Invoke(nameof(GetSpecialType), typeId, diagnostics, node);
        public ISymbol GetSpecialTypeMember(Int32 member, Object diagnostics, SyntaxNode syntax) => (ISymbol)proxy.Invoke(nameof(GetSpecialTypeMember), member, diagnostics, syntax);
        public INamedTypeSymbol GetWellKnownType(Int32 type, Object diagnostics, SyntaxNode node) => (INamedTypeSymbol)proxy.Invoke(nameof(GetWellKnownType), type, diagnostics, node);
        public ISymbol ResultSymbol(Object result, String simpleName, Int32 arity, SyntaxNode where, Object diagnostics, Boolean suppressUseSiteDiagnostics, Object wasError, INamespaceOrTypeSymbol qualifierOpt = null, Int32 options = 0) => (ISymbol)proxy.Invoke(nameof(ResultSymbol), result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, wasError, qualifierOpt, options);
        public ValueType GetBestSymbolInfo(Object symbols, Object secondBest) => (ValueType)proxy.Invoke(nameof(GetBestSymbolInfo), symbols, secondBest);
        public Object NotFound(SyntaxNode where, String simpleName, Int32 arity, String whereText, Object diagnostics, String aliasOpt, INamespaceOrTypeSymbol qualifierOpt, Int32 options) => (Object)proxy.Invoke(nameof(NotFound), where, simpleName, arity, whereText, diagnostics, aliasOpt, qualifierOpt, options);
        public IAssemblySymbol GetForwardedToAssembly(String fullName, Int32 arity, Object diagnostics, Location location) => (IAssemblySymbol)proxy.Invoke(nameof(GetForwardedToAssembly), fullName, arity, diagnostics, location);
        public Boolean ReportUnsafeIfNotAllowed(SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportUnsafeIfNotAllowed), node, diagnostics);
        public Boolean ReportUnsafeIfNotAllowed(SyntaxNode node, ITypeSymbol sizeOfTypeOpt, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportUnsafeIfNotAllowed), node, sizeOfTypeOpt, diagnostics);
        public Boolean ReportUnsafeIfNotAllowed(Location location, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportUnsafeIfNotAllowed), location, diagnostics);
        public Boolean ReportUnsafeIfNotAllowed(Location location, ITypeSymbol sizeOfTypeOpt, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportUnsafeIfNotAllowed), location, sizeOfTypeOpt, diagnostics);
        public Object GetUnsafeDiagnosticInfo(ITypeSymbol sizeOfTypeOpt) => (Object)proxy.Invoke(nameof(GetUnsafeDiagnosticInfo), sizeOfTypeOpt);
        public ImmutableArray<ISymbol> BindXmlNameAttribute(XmlNameAttributeSyntax syntax, Object useSiteDiagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindXmlNameAttribute), syntax, useSiteDiagnostics);
        public IOperation BindCheckedStatement(CheckedStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCheckedStatement), node, diagnostics);
        public IOperation BindUnsafeStatement(UnsafeStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindUnsafeStatement), node, diagnostics);
        public IOperation BindFixedStatement(FixedStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindFixedStatement), node, diagnostics);
        public IOperation BindFixedStatementParts(FixedStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindFixedStatementParts), node, diagnostics);
        public IOperation BindYieldReturnStatement(YieldStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindYieldReturnStatement), node, diagnostics);
        public IOperation BindYieldBreakStatement(YieldStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindYieldBreakStatement), node, diagnostics);
        public IOperation BindLockStatement(LockStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindLockStatement), node, diagnostics);
        public IOperation BindLockStatementParts(Object diagnostics, Object originalBinder) => (IOperation)proxy.Invoke(nameof(BindLockStatementParts), diagnostics, originalBinder);
        public IOperation BindUsingStatement(UsingStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindUsingStatement), node, diagnostics);
        public IOperation BindUsingStatementParts(Object diagnostics, Object originalBinder) => (IOperation)proxy.Invoke(nameof(BindUsingStatementParts), diagnostics, originalBinder);
        public IOperation BindPossibleEmbeddedStatement(StatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindPossibleEmbeddedStatement), node, diagnostics);
        public IOperation BindThrownExpression(ExpressionSyntax exprSyntax, Object diagnostics, Object hasErrors) => (IOperation)proxy.Invoke(nameof(BindThrownExpression), exprSyntax, diagnostics, hasErrors);
        public IOperation BindThrow(ThrowStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindThrow), node, diagnostics);
        public ILabelStatement BindLabeled(LabeledStatementSyntax node, Object diagnostics) => (ILabelStatement)proxy.Invoke(nameof(BindLabeled), node, diagnostics);
        public IOperation BindGoto(GotoStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindGoto), node, diagnostics);
        public IOperation BindLocalFunctionStatement(LocalFunctionStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindLocalFunctionStatement), node, diagnostics);
        public Boolean ImplicitReturnIsOkay(IMethodSymbol method) => (Boolean)proxy.Invoke(nameof(ImplicitReturnIsOkay), method);
        public IOperation BindExpressionStatement(ExpressionStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindExpressionStatement), node, diagnostics);
        public IExpressionStatement BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, Object diagnostics) => (IExpressionStatement)proxy.Invoke(nameof(BindExpressionStatement), node, syntax, allowsAnyExpression, diagnostics);
        public void CheckForUnobservedAwaitable(IOperation expression, Object diagnostics) => proxy.Invoke(nameof(CheckForUnobservedAwaitable), expression, diagnostics);
        public IOperation BindLocalDeclarationStatement(LocalDeclarationStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindLocalDeclarationStatement), node, diagnostics);
        public IOperation BindDeclarationStatementParts(LocalDeclarationStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeclarationStatementParts), node, diagnostics);
        public ITypeSymbol BindVariableType(CSharpSyntaxNode declarationNode, Object diagnostics, TypeSyntax typeSyntax, Object isConst, Object isVar, Object alias) => (ITypeSymbol)proxy.Invoke(nameof(BindVariableType), declarationNode, diagnostics, typeSyntax, isConst, isVar, alias);
        public IOperation BindInferredVariableInitializer(Object diagnostics, Byte refKind, EqualsValueClauseSyntax initializer, CSharpSyntaxNode errorSyntax) => (IOperation)proxy.Invoke(nameof(BindInferredVariableInitializer), diagnostics, refKind, initializer, errorSyntax);
        public IOperation BindInferredVariableInitializer(Object diagnostics, ExpressionSyntax initializer, Byte valueKind, CSharpSyntaxNode errorSyntax) => (IOperation)proxy.Invoke(nameof(BindInferredVariableInitializer), diagnostics, initializer, valueKind, errorSyntax);
        public IVariableDeclarationStatement BindVariableDeclaration(Byte kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, ITypeSymbol declTypeOpt, IAliasSymbol aliasOpt, Object diagnostics, CSharpSyntaxNode associatedSyntaxNode = null) => (IVariableDeclarationStatement)proxy.Invoke(nameof(BindVariableDeclaration), kind, isVar, declarator, typeSyntax, declTypeOpt, aliasOpt, diagnostics, associatedSyntaxNode);
        public IVariableDeclarationStatement BindVariableDeclaration(ILocalSymbol localSymbol, Byte kind, Boolean isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, ITypeSymbol declTypeOpt, IAliasSymbol aliasOpt, Object diagnostics, CSharpSyntaxNode associatedSyntaxNode = null) => (IVariableDeclarationStatement)proxy.Invoke(nameof(BindVariableDeclaration), localSymbol, kind, isVar, declarator, typeSyntax, declTypeOpt, aliasOpt, diagnostics, associatedSyntaxNode);
        public ImmutableArray<IOperation> BindDeclaratorArguments(VariableDeclaratorSyntax declarator, Object diagnostics) => (ImmutableArray<IOperation>)proxy.Invoke(nameof(BindDeclaratorArguments), declarator, diagnostics);
        public ILocalSymbol LocateDeclaredVariableSymbol(VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax) => (ILocalSymbol)proxy.Invoke(nameof(LocateDeclaredVariableSymbol), declarator, typeSyntax);
        public ILocalSymbol LocateDeclaredVariableSymbol(SyntaxToken identifier, TypeSyntax typeSyntax, EqualsValueClauseSyntax equalsValue) => (ILocalSymbol)proxy.Invoke(nameof(LocateDeclaredVariableSymbol), identifier, typeSyntax, equalsValue);
        public Boolean IsValidFixedVariableInitializer(ITypeSymbol declType, ILocalSymbol localSymbol, Object initializerOpt, Object diagnostics) => (Boolean)proxy.Invoke(nameof(IsValidFixedVariableInitializer), declType, localSymbol, initializerOpt, diagnostics);
        public IOperation GetFixedLocalCollectionInitializer(IOperation initializer, ITypeSymbol elementType, ITypeSymbol declType, Boolean hasErrors, Object diagnostics) => (IOperation)proxy.Invoke(nameof(GetFixedLocalCollectionInitializer), initializer, elementType, declType, hasErrors, diagnostics);
        public IOperation BindAssignment(AssignmentExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAssignment), node, diagnostics);
        public IOperation InferTypeForDiscardAssignment(IOperation op1, IOperation op2, Object diagnostics) => (IOperation)proxy.Invoke(nameof(InferTypeForDiscardAssignment), op1, op2, diagnostics);
        public IAssignmentExpression BindAssignment(SyntaxNode node, IOperation op1, IOperation op2, Object diagnostics) => (IAssignmentExpression)proxy.Invoke(nameof(BindAssignment), node, op1, op2, diagnostics);
        public Object GetBadEventUsageDiagnosticInfo(IEventSymbol eventSymbol) => (Object)proxy.Invoke(nameof(GetBadEventUsageDiagnosticInfo), eventSymbol);
        public ITypeSymbol GetAccessThroughType(IOperation receiver) => (ITypeSymbol)proxy.Invoke(nameof(GetAccessThroughType), receiver);
        public IOperation BindPossibleArrayInitializer(ExpressionSyntax node, ITypeSymbol destinationType, Byte valueKind, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindPossibleArrayInitializer), node, destinationType, valueKind, diagnostics);
        public ILocalSymbol LookupLocal(SyntaxToken nameToken) => (ILocalSymbol)proxy.Invoke(nameof(LookupLocal), nameToken);
        public IMethodSymbol LookupLocalFunction(SyntaxToken nameToken) => (IMethodSymbol)proxy.Invoke(nameof(LookupLocalFunction), nameToken);
        public IBlockStatement BindEmbeddedBlock(BlockSyntax node, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(BindEmbeddedBlock), node, diagnostics);
        public IBlockStatement BindBlock(BlockSyntax node, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(BindBlock), node, diagnostics);
        public IBlockStatement BindBlockParts(BlockSyntax node, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(BindBlockParts), node, diagnostics);
        public IOperation GenerateConversionForAssignment(ITypeSymbol targetType, IOperation expression, Object diagnostics, Boolean isDefaultParameter = false, Byte refKind = 0) => (IOperation)proxy.Invoke(nameof(GenerateConversionForAssignment), targetType, expression, diagnostics, isDefaultParameter, refKind);
        public void GenerateAnonymousFunctionConversionError(Object diagnostics, SyntaxNode syntax, IUnboundLambdaExpression anonymousFunction, ITypeSymbol targetType) => proxy.Invoke(nameof(GenerateAnonymousFunctionConversionError), diagnostics, syntax, anonymousFunction, targetType);
        public void GenerateImplicitConversionError(Object diagnostics, SyntaxNode syntax, Conversion conversion, IOperation operand, ITypeSymbol targetType) => proxy.Invoke(nameof(GenerateImplicitConversionError), diagnostics, syntax, conversion, operand, targetType);
        public void GenerateImplicitConversionErrorsForTupleLiteralArguments(Object diagnostics, ImmutableArray<IOperation> tupleArguments, ImmutableArray<INamespaceOrTypeSymbol> targetElementTypes) => proxy.Invoke(nameof(GenerateImplicitConversionErrorsForTupleLiteralArguments), diagnostics, tupleArguments, targetElementTypes);
        public IOperation BindIfStatement(IfStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIfStatement), node, diagnostics);
        public IOperation BindBooleanExpression(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindBooleanExpression), node, diagnostics);
        public IOperation BindSwitchStatement(SwitchStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindSwitchStatement), node, diagnostics);
        public IOperation BindSwitchExpressionAndSections(SwitchStatementSyntax node, Object originalBinder, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindSwitchExpressionAndSections), node, originalBinder, diagnostics);
        public void BindPatternSwitchLabelForInference(CasePatternSwitchLabelSyntax node, Object diagnostics) => proxy.Invoke(nameof(BindPatternSwitchLabelForInference), node, diagnostics);
        public IOperation BindWhile(WhileStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindWhile), node, diagnostics);
        public IWhileUntilLoopStatement BindWhileParts(Object diagnostics, Object originalBinder) => (IWhileUntilLoopStatement)proxy.Invoke(nameof(BindWhileParts), diagnostics, originalBinder);
        public IOperation BindDo(DoStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDo), node, diagnostics);
        public IWhileUntilLoopStatement BindDoParts(Object diagnostics, Object originalBinder) => (IWhileUntilLoopStatement)proxy.Invoke(nameof(BindDoParts), diagnostics, originalBinder);
        public IForLoopStatement BindFor(ForStatementSyntax node, Object diagnostics) => (IForLoopStatement)proxy.Invoke(nameof(BindFor), node, diagnostics);
        public IForLoopStatement BindForParts(Object diagnostics, Object originalBinder) => (IForLoopStatement)proxy.Invoke(nameof(BindForParts), diagnostics, originalBinder);
        public IOperation BindForOrUsingOrFixedDeclarations(VariableDeclarationSyntax nodeOpt, Byte localKind, Object diagnostics, Object declarations) => (IOperation)proxy.Invoke(nameof(BindForOrUsingOrFixedDeclarations), nodeOpt, localKind, diagnostics, declarations);
        public IOperation BindStatementExpressionList(SeparatedSyntaxList<ExpressionSyntax> statements, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindStatementExpressionList), statements, diagnostics);
        public IOperation BindForEach(CommonForEachStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindForEach), node, diagnostics);
        public IOperation BindForEachParts(Object diagnostics, Object originalBinder) => (IOperation)proxy.Invoke(nameof(BindForEachParts), diagnostics, originalBinder);
        public IOperation BindForEachDeconstruction(Object diagnostics, Object originalBinder) => (IOperation)proxy.Invoke(nameof(BindForEachDeconstruction), diagnostics, originalBinder);
        public IOperation BindBreak(BreakStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindBreak), node, diagnostics);
        public IOperation BindContinue(ContinueStatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindContinue), node, diagnostics);
        public Boolean IsInAsyncMethod() => (Boolean)proxy.Invoke(nameof(IsInAsyncMethod));
        public Boolean IsTaskReturningAsyncMethod() => (Boolean)proxy.Invoke(nameof(IsTaskReturningAsyncMethod));
        public Boolean IsGenericTaskReturningAsyncMethod() => (Boolean)proxy.Invoke(nameof(IsGenericTaskReturningAsyncMethod));
        public ITypeSymbol GetCurrentReturnType(Object refKind) => (ITypeSymbol)proxy.Invoke(nameof(GetCurrentReturnType), refKind);
        public IOperation BindReturn(ReturnStatementSyntax syntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindReturn), syntax, diagnostics);
        public IOperation CreateReturnConversion(SyntaxNode syntax, Object diagnostics, IOperation argument, Byte returnRefKind, ITypeSymbol returnType) => (IOperation)proxy.Invoke(nameof(CreateReturnConversion), syntax, diagnostics, argument, returnRefKind, returnType);
        public ITryStatement BindTryStatement(TryStatementSyntax node, Object diagnostics) => (ITryStatement)proxy.Invoke(nameof(BindTryStatement), node, diagnostics);
        public ImmutableArray<IOperation> BindCatchBlocks(SyntaxList<CatchClauseSyntax> catchClauses, Object diagnostics) => (ImmutableArray<IOperation>)proxy.Invoke(nameof(BindCatchBlocks), catchClauses, diagnostics);
        public IOperation BindCatchBlock(CatchClauseSyntax node, Object previousBlocks, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCatchBlock), node, previousBlocks, diagnostics);
        public IOperation BindCatchFilter(CatchFilterClauseSyntax filter, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCatchFilter), filter, diagnostics);
        public void ReportCantConvertLambdaReturn(SyntaxNode syntax, Object diagnostics) => proxy.Invoke(nameof(ReportCantConvertLambdaReturn), syntax, diagnostics);
        public IBlockStatement CreateBlockFromExpression(CSharpSyntaxNode node, ImmutableArray<ISymbol> locals, Byte refKind, IOperation expression, ExpressionSyntax expressionSyntax, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(CreateBlockFromExpression), node, locals, refKind, expression, expressionSyntax, diagnostics);
        public Object FoldUnaryOperator(CSharpSyntaxNode syntax, Int32 kind, IOperation operand, SByte resultType, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldUnaryOperator), syntax, kind, operand, resultType, diagnostics);
        public ILiteralExpression BindIntegralMinValConstants(PrefixUnaryExpressionSyntax node, IOperation operand, Object diagnostics) => (ILiteralExpression)proxy.Invoke(nameof(BindIntegralMinValConstants), node, operand, diagnostics);
        public Boolean IsOperandErrors(CSharpSyntaxNode node, Object operand, Object diagnostics) => (Boolean)proxy.Invoke(nameof(IsOperandErrors), node, operand, diagnostics);
        public Boolean IsOperatorErrors(CSharpSyntaxNode node, ITypeSymbol operandType, IOperation typeExpression, Object diagnostics) => (Boolean)proxy.Invoke(nameof(IsOperatorErrors), node, operandType, typeExpression, diagnostics);
        public IOperation BindIsOperator(BinaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIsOperator), node, diagnostics);
        public IOperation BindAsOperator(BinaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAsOperator), node, diagnostics);
        public IOperation GenerateNullCoalescingBadBinaryOpsError(BinaryExpressionSyntax node, IOperation leftOperand, IOperation rightOperand, Conversion leftConversion, Object diagnostics) => (IOperation)proxy.Invoke(nameof(GenerateNullCoalescingBadBinaryOpsError), node, leftOperand, rightOperand, leftConversion, diagnostics);
        public IOperation BindNullCoalescingOperator(BinaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNullCoalescingOperator), node, diagnostics);
        public IOperation BindConditionalOperator(ConditionalExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConditionalOperator), node, diagnostics);
        public IOperation BindIsPatternExpression(IsPatternExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIsPatternExpression), node, diagnostics);
        public IOperation BindPattern(PatternSyntax node, IOperation operand, ITypeSymbol operandType, Boolean hasErrors, Object diagnostics, Boolean wasSwitchCase = false) => (IOperation)proxy.Invoke(nameof(BindPattern), node, operand, operandType, hasErrors, diagnostics, wasSwitchCase);
        public IOperation BindConstantPattern(ConstantPatternSyntax node, IOperation operand, ITypeSymbol operandType, Boolean hasErrors, Object diagnostics, Boolean wasSwitchCase) => (IOperation)proxy.Invoke(nameof(BindConstantPattern), node, operand, operandType, hasErrors, diagnostics, wasSwitchCase);
        public IOperation BindConstantPattern(CSharpSyntaxNode node, IOperation operand, ITypeSymbol operandType, ExpressionSyntax patternExpression, Boolean hasErrors, Object diagnostics, Object wasExpression, Boolean wasSwitchCase) => (IOperation)proxy.Invoke(nameof(BindConstantPattern), node, operand, operandType, patternExpression, hasErrors, diagnostics, wasExpression, wasSwitchCase);
        public IOperation ConvertPatternExpression(ITypeSymbol inputType, CSharpSyntaxNode node, IOperation expression, Object constantValue, Object diagnostics) => (IOperation)proxy.Invoke(nameof(ConvertPatternExpression), inputType, node, expression, constantValue, diagnostics);
        public Boolean CheckValidPatternType(CSharpSyntaxNode typeSyntax, IOperation operand, ITypeSymbol operandType, ITypeSymbol patternType, Boolean patternTypeWasInSource, Boolean isVar, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckValidPatternType), typeSyntax, operand, operandType, patternType, patternTypeWasInSource, isVar, diagnostics);
        public IOperation BindDeclarationPattern(DeclarationPatternSyntax node, IOperation operand, ITypeSymbol operandType, Boolean hasErrors, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeclarationPattern), node, operand, operandType, hasErrors, diagnostics);
        public IOperation BindQuery(QueryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindQuery), node, diagnostics);
        public IOperation BindQueryInternal1(Object state, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindQueryInternal1), state, diagnostics);
        public IOperation BindQueryInternal2(Object state, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindQueryInternal2), state, diagnostics);
        public IOperation FinalTranslation(Object state, Object diagnostics) => (IOperation)proxy.Invoke(nameof(FinalTranslation), state, diagnostics);
        public void ReduceQuery(Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceQuery), state, diagnostics);
        public void ReduceWhere(WhereClauseSyntax where, Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceWhere), where, state, diagnostics);
        public void ReduceJoin(JoinClauseSyntax join, Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceJoin), join, state, diagnostics);
        public void ReduceOrderBy(OrderByClauseSyntax orderby, Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceOrderBy), orderby, state, diagnostics);
        public void ReduceFrom(FromClauseSyntax from, Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceFrom), from, state, diagnostics);
        public IUnboundLambdaExpression MakePairLambda(CSharpSyntaxNode node, Object state, IRangeVariableSymbol x1, IRangeVariableSymbol x2) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakePairLambda), node, state, x1, x2);
        public void ReduceLet(LetClauseSyntax let, Object state, Object diagnostics) => proxy.Invoke(nameof(ReduceLet), let, state, diagnostics);
        public IBlockStatement CreateLambdaBlockForQueryClause(ExpressionSyntax expression, IOperation result, Object diagnostics) => (IBlockStatement)proxy.Invoke(nameof(CreateLambdaBlockForQueryClause), expression, result, diagnostics);
        public IOperation MakeQueryClause(CSharpSyntaxNode syntax, IOperation expression, IRangeVariableSymbol definedSymbol = null, IOperation queryInvocation = null, IOperation castInvocation = null, IOperation unoptimizedForm = null) => (IOperation)proxy.Invoke(nameof(MakeQueryClause), syntax, expression, definedSymbol, queryInvocation, castInvocation, unoptimizedForm);
        public IOperation MakePair(CSharpSyntaxNode node, String field1Name, IOperation field1Value, String field2Name, IOperation field2Value, Object state, Object diagnostics) => (IOperation)proxy.Invoke(nameof(MakePair), node, field1Name, field1Value, field2Name, field2Value, state, diagnostics);
        public ITypeSymbol TypeOrError(IOperation e) => (ITypeSymbol)proxy.Invoke(nameof(TypeOrError), e);
        public IUnboundLambdaExpression MakeQueryUnboundLambda(Dictionary<IRangeVariableSymbol, ImmutableArray<String>> qvm, IRangeVariableSymbol parameter, ExpressionSyntax expression) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakeQueryUnboundLambda), qvm, parameter, expression);
        public IUnboundLambdaExpression MakeQueryUnboundLambda(Dictionary<IRangeVariableSymbol, ImmutableArray<String>> qvm, ImmutableArray<ISymbol> parameters, ExpressionSyntax expression) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakeQueryUnboundLambda), qvm, parameters, expression);
        public IUnboundLambdaExpression MakeQueryUnboundLambdaWithCast(Dictionary<IRangeVariableSymbol, ImmutableArray<String>> qvm, IRangeVariableSymbol parameter, ExpressionSyntax expression, TypeSyntax castTypeSyntax, ITypeSymbol castType) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakeQueryUnboundLambdaWithCast), qvm, parameter, expression, castTypeSyntax, castType);
        public IUnboundLambdaExpression MakeQueryUnboundLambda(Dictionary<IRangeVariableSymbol, ImmutableArray<String>> qvm, ImmutableArray<ISymbol> parameters, CSharpSyntaxNode node, MulticastDelegate bodyFactory) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakeQueryUnboundLambda), qvm, parameters, node, bodyFactory);
        public IUnboundLambdaExpression MakeQueryUnboundLambda(CSharpSyntaxNode node, Object state) => (IUnboundLambdaExpression)proxy.Invoke(nameof(MakeQueryUnboundLambda), node, state);
        public IInvocationExpression MakeQueryInvocation(CSharpSyntaxNode node, IOperation receiver, String methodName, IOperation arg, Object diagnostics) => (IInvocationExpression)proxy.Invoke(nameof(MakeQueryInvocation), node, receiver, methodName, arg, diagnostics);
        public IInvocationExpression MakeQueryInvocation(CSharpSyntaxNode node, IOperation receiver, String methodName, ImmutableArray<IOperation> args, Object diagnostics) => (IInvocationExpression)proxy.Invoke(nameof(MakeQueryInvocation), node, receiver, methodName, args, diagnostics);
        public IInvocationExpression MakeQueryInvocation(CSharpSyntaxNode node, IOperation receiver, String methodName, TypeSyntax typeArgSyntax, ITypeSymbol typeArg, Object diagnostics) => (IInvocationExpression)proxy.Invoke(nameof(MakeQueryInvocation), node, receiver, methodName, typeArgSyntax, typeArg, diagnostics);
        public IInvocationExpression MakeQueryInvocation(CSharpSyntaxNode node, IOperation receiver, String methodName, SeparatedSyntaxList<TypeSyntax> typeArgsSyntax, ImmutableArray<INamespaceOrTypeSymbol> typeArgs, ImmutableArray<IOperation> args, Object diagnostics) => (IInvocationExpression)proxy.Invoke(nameof(MakeQueryInvocation), node, receiver, methodName, typeArgsSyntax, typeArgs, args, diagnostics);
        public IOperation MakeConstruction(CSharpSyntaxNode node, INamedTypeSymbol toCreate, ImmutableArray<IOperation> args, Object diagnostics) => (IOperation)proxy.Invoke(nameof(MakeConstruction), node, toCreate, args, diagnostics);
        public void ReportQueryLookupFailed(SyntaxNode queryClause, IOperation instanceArgument, String name, ImmutableArray<ISymbol> symbols, Object diagnostics) => proxy.Invoke(nameof(ReportQueryLookupFailed), queryClause, instanceArgument, name, symbols, diagnostics);
        public Boolean ImplementsStandardQueryInterface(ITypeSymbol instanceType, String name, Object useSiteDiagnostics) => (Boolean)proxy.Invoke(nameof(ImplementsStandardQueryInterface), instanceType, name, useSiteDiagnostics);
        public Boolean HasCastToQueryProvider(ITypeSymbol instanceType, Object useSiteDiagnostics) => (Boolean)proxy.Invoke(nameof(HasCastToQueryProvider), instanceType, useSiteDiagnostics);
        public IOperation BindDeconstruction(AssignmentExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeconstruction), node, diagnostics);
        public IOperation BindDeconstruction(CSharpSyntaxNode deconstruction, ExpressionSyntax left, ExpressionSyntax right, Object diagnostics, Object declaration, Object expression, IPlaceholderExpression rightPlaceholder = null) => (IOperation)proxy.Invoke(nameof(BindDeconstruction), deconstruction, left, right, diagnostics, declaration, expression, rightPlaceholder);
        public IOperation BindDeconstructionAssignment(CSharpSyntaxNode node, ExpressionSyntax left, IOperation boundRHS, Object checkedVariables, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeconstructionAssignment), node, left, boundRHS, checkedVariables, diagnostics);
        public IOperation FixTupleLiteral(Object checkedVariables, IOperation boundRHS, CSharpSyntaxNode syntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(FixTupleLiteral), checkedVariables, boundRHS, syntax, diagnostics);
        public Boolean MakeDeconstructionConversion(ITypeSymbol type, SyntaxNode syntax, SyntaxNode rightSyntax, Object diagnostics, Object variables, Object conversion) => (Boolean)proxy.Invoke(nameof(MakeDeconstructionConversion), type, syntax, rightSyntax, diagnostics, variables, conversion);
        public void SetInferredTypes(Object variables, ImmutableArray<INamespaceOrTypeSymbol> foundTypes, Object diagnostics) => proxy.Invoke(nameof(SetInferredTypes), variables, foundTypes, diagnostics);
        public IOperation SetInferredType(IOperation expression, ITypeSymbol type, Object diagnostics) => (IOperation)proxy.Invoke(nameof(SetInferredType), expression, type, diagnostics);
        public void FailRemainingInferences(Object variables, Object diagnostics) => proxy.Invoke(nameof(FailRemainingInferences), variables, diagnostics);
        public IOperation DeconstructionVariablesAsTuple(CSharpSyntaxNode syntax, Object variables, Object diagnostics, Boolean hasErrors) => (IOperation)proxy.Invoke(nameof(DeconstructionVariablesAsTuple), syntax, variables, diagnostics, hasErrors);
        public IOperation MakeDeconstructInvocationExpression(Int32 numCheckedVariables, IOperation receiver, SyntaxNode rightSyntax, Object diagnostics, Object outPlaceholders) => (IOperation)proxy.Invoke(nameof(MakeDeconstructInvocationExpression), numCheckedVariables, receiver, rightSyntax, diagnostics, outPlaceholders);
        public IInvalidExpression MissingDeconstruct(IOperation receiver, SyntaxNode rightSyntax, Int32 numParameters, Object diagnostics, Object outPlaceholders, IOperation childNode) => (IInvalidExpression)proxy.Invoke(nameof(MissingDeconstruct), receiver, rightSyntax, numParameters, diagnostics, outPlaceholders, childNode);
        public Object BindDeconstructionVariables(ExpressionSyntax node, Object diagnostics, Object declaration, Object expression) => (Object)proxy.Invoke(nameof(BindDeconstructionVariables), node, diagnostics, declaration, expression);
        public Object BindDeconstructionVariables(ITypeSymbol declType, VariableDesignationSyntax node, CSharpSyntaxNode syntax, Object diagnostics) => (Object)proxy.Invoke(nameof(BindDeconstructionVariables), declType, node, syntax, diagnostics);
        public IOperation BindDeconstructionVariable(ITypeSymbol declType, SingleVariableDesignationSyntax designation, CSharpSyntaxNode syntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeconstructionVariable), declType, designation, syntax, diagnostics);
        public IOperation BindStatement(StatementSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindStatement), node, diagnostics);
        public Boolean CheckAttributeTypeViability(ISymbol symbol, Boolean diagnose, Object diagInfo) => (Boolean)proxy.Invoke(nameof(CheckAttributeTypeViability), symbol, diagnose, diagInfo);
        public void GetCandidateExtensionMethods(Boolean searchUsingsNotNamespace, Object methods, String name, Int32 arity, Int32 options, Object originalBinder) => proxy.Invoke(nameof(GetCandidateExtensionMethods), searchUsingsNotNamespace, methods, name, arity, options, originalBinder);
        public void LookupMembersInClass(Object result, ITypeSymbol type, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInClass), result, type, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void AddWinRTMembers(Object result, INamedTypeSymbol type, String name, Int32 arity, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(AddWinRTMembers), result, type, name, arity, options, originalBinder, diagnose, useSiteDiagnostics);
        public void GetWellKnownWinRTMemberInterfaces(Object idictSymbol, Object iroDictSymbol, Object iListSymbol, Object iCollectionSymbol, Object inccSymbol, Object inpcSymbol) => proxy.Invoke(nameof(GetWellKnownWinRTMemberInterfaces), idictSymbol, iroDictSymbol, iListSymbol, iCollectionSymbol, inccSymbol, inpcSymbol);
        public void LookupMembersInInterface(Object current, INamedTypeSymbol type, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInInterface), current, type, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupMembersInTypeParameter(Object current, ITypeParameterSymbol typeParameter, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInTypeParameter), current, typeParameter, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public ValueType CheckViability(ISymbol symbol, Int32 arity, Int32 options, ITypeSymbol accessThroughType, Boolean diagnose, Object useSiteDiagnostics, Object basesBeingResolved = null) => (ValueType)proxy.Invoke(nameof(CheckViability), symbol, arity, options, accessThroughType, diagnose, useSiteDiagnostics, basesBeingResolved);
        public Object MakeCallMethodsDirectlyDiagnostic(ISymbol symbol) => (Object)proxy.Invoke(nameof(MakeCallMethodsDirectlyDiagnostic), symbol);
        public void CheckViability(Object result, ImmutableArray<ISymbol> symbols, Int32 arity, Int32 options, ITypeSymbol accessThroughType, Boolean diagnose, Object useSiteDiagnostics, Object basesBeingResolved) => proxy.Invoke(nameof(CheckViability), result, symbols, arity, options, accessThroughType, diagnose, useSiteDiagnostics, basesBeingResolved);
        public Boolean CanAddLookupSymbolInfo(ISymbol symbol, Int32 options, ITypeSymbol accessThroughType) => (Boolean)proxy.Invoke(nameof(CanAddLookupSymbolInfo), symbol, options, accessThroughType);
        public Boolean IsCrefAccessible(ISymbol symbol) => (Boolean)proxy.Invoke(nameof(IsCrefAccessible), symbol);
        public Boolean IsAccessible(ISymbol symbol, Object useSiteDiagnostics, ITypeSymbol accessThroughType = null, Object basesBeingResolved = null) => (Boolean)proxy.Invoke(nameof(IsAccessible), symbol, useSiteDiagnostics, accessThroughType, basesBeingResolved);
        public Boolean IsAccessible(ISymbol symbol, ITypeSymbol accessThroughType, Object failedThroughTypeCheck, Object useSiteDiagnostics, Object basesBeingResolved = null) => (Boolean)proxy.Invoke(nameof(IsAccessible), symbol, accessThroughType, failedThroughTypeCheck, useSiteDiagnostics, basesBeingResolved);
        public Boolean IsAccessibleHelper(ISymbol symbol, ITypeSymbol accessThroughType, Object failedThroughTypeCheck, Object useSiteDiagnostics, Object basesBeingResolved) => (Boolean)proxy.Invoke(nameof(IsAccessibleHelper), symbol, accessThroughType, failedThroughTypeCheck, useSiteDiagnostics, basesBeingResolved);
        public Boolean IsNonInvocableMember(ISymbol symbol) => (Boolean)proxy.Invoke(nameof(IsNonInvocableMember), symbol);
        public Boolean IsInvocableMember(ISymbol symbol) => (Boolean)proxy.Invoke(nameof(IsInvocableMember), symbol);
        public void AddLookupSymbolsInfo(Object result, Int32 options = 0) => proxy.Invoke(nameof(AddLookupSymbolsInfo), result, options);
        public void AddLookupSymbolsInfoInSingleBinder(Object info, Int32 options, Object originalBinder) => proxy.Invoke(nameof(AddLookupSymbolsInfoInSingleBinder), info, options, originalBinder);
        public void AddMemberLookupSymbolsInfo(Object result, INamespaceOrTypeSymbol nsOrType, Int32 options, Object originalBinder) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfo), result, nsOrType, options, originalBinder);
        public void AddMemberLookupSymbolsInfoInType(Object result, ITypeSymbol type, Int32 options, Object originalBinder) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfoInType), result, type, options, originalBinder);
        public void AddMemberLookupSymbolsInfoInSubmissions(Object result, ITypeSymbol scriptClass, Int32 options, Object originalBinder) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfoInSubmissions), result, scriptClass, options, originalBinder);
        public void AddWinRTMembersLookupSymbolsInfo(Object result, INamedTypeSymbol type, Int32 options, Object originalBinder, ITypeSymbol accessThroughType) => proxy.Invoke(nameof(AddWinRTMembersLookupSymbolsInfo), result, type, options, originalBinder, accessThroughType);
        public void AddMemberLookupSymbolsInfoInClass(Object result, ITypeSymbol type, Int32 options, Object originalBinder, ITypeSymbol accessThroughType) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfoInClass), result, type, options, originalBinder, accessThroughType);
        public void AddMemberLookupSymbolsInfoInInterface(Object result, ITypeSymbol type, Int32 options, Object originalBinder, ITypeSymbol accessThroughType) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfoInInterface), result, type, options, originalBinder, accessThroughType);
        public void AddMemberLookupSymbolsInfoInTypeParameter(Object result, ITypeParameterSymbol type, Int32 options, Object originalBinder) => proxy.Invoke(nameof(AddMemberLookupSymbolsInfoInTypeParameter), result, type, options, originalBinder);
        public Boolean ValidateLambdaParameterNameConflictsInScope(Location location, String name, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ValidateLambdaParameterNameConflictsInScope), location, name, diagnostics);
        public Boolean ValidateDeclarationNameConflictsInScope(ISymbol symbol, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ValidateDeclarationNameConflictsInScope), symbol, diagnostics);
        public void ValidateParameterNameConflicts(ImmutableArray<ITypeSymbol> typeParameters, ImmutableArray<ISymbol> parameters, Object diagnostics) => proxy.Invoke(nameof(ValidateParameterNameConflicts), typeParameters, parameters, diagnostics);
        public Boolean ValidateNameConflictsInScope(ISymbol symbol, Location location, String name, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ValidateNameConflictsInScope), symbol, location, name, diagnostics);
        public IOperation BindCompoundAssignment(AssignmentExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCompoundAssignment), node, diagnostics);
        public IOperation BindEventAssignment(AssignmentExpressionSyntax node, IEventReferenceExpression left, IOperation right, Int32 opKind, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindEventAssignment), node, left, right, opKind, diagnostics);
        public IOperation BindDynamicBinaryOperator(BinaryExpressionSyntax node, Int32 kind, IOperation left, IOperation right, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDynamicBinaryOperator), node, kind, left, right, diagnostics);
        public IOperation BindSimpleBinaryOperator(BinaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindSimpleBinaryOperator), node, diagnostics);
        public IOperation BindSimpleBinaryOperator(BinaryExpressionSyntax node, Object diagnostics, IOperation left, IOperation right, Object compoundStringLength) => (IOperation)proxy.Invoke(nameof(BindSimpleBinaryOperator), node, diagnostics, left, right, compoundStringLength);
        public void ReportAssignmentOperatorError(AssignmentExpressionSyntax node, Object diagnostics, IOperation left, IOperation right, Byte resultKind) => proxy.Invoke(nameof(ReportAssignmentOperatorError), node, diagnostics, left, right, resultKind);
        public IOperation BindConditionalLogicalOperator(BinaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConditionalLogicalOperator), node, diagnostics);
        public IOperation BindConditionalLogicalOperator(BinaryExpressionSyntax node, IOperation left, IOperation right, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConditionalLogicalOperator), node, left, right, diagnostics);
        public Boolean IsValidDynamicCondition(IOperation left, Boolean isNegative, Object useSiteDiagnostics, Object userDefinedOperator) => (Boolean)proxy.Invoke(nameof(IsValidDynamicCondition), left, isNegative, useSiteDiagnostics, userDefinedOperator);
        public Boolean IsValidUserDefinedConditionalLogicalOperator(CSharpSyntaxNode syntax, ValueType signature, Object diagnostics, Object trueOperator, Object falseOperator) => (Boolean)proxy.Invoke(nameof(IsValidUserDefinedConditionalLogicalOperator), syntax, signature, diagnostics, trueOperator, falseOperator);
        public Boolean HasApplicableBooleanOperator(INamedTypeSymbol containingType, String name, ITypeSymbol argumentType, Object useSiteDiagnostics, Object @operator) => (Boolean)proxy.Invoke(nameof(HasApplicableBooleanOperator), containingType, name, argumentType, useSiteDiagnostics, @operator);
        public ITypeSymbol GetBinaryOperatorErrorType(Int32 kind, Object diagnostics, CSharpSyntaxNode node) => (ITypeSymbol)proxy.Invoke(nameof(GetBinaryOperatorErrorType), kind, diagnostics, node);
        public ValueType BinaryOperatorOverloadResolution(Int32 kind, IOperation left, IOperation right, CSharpSyntaxNode node, Object diagnostics, Object resultKind, Object originalUserDefinedOperators) => (ValueType)proxy.Invoke(nameof(BinaryOperatorOverloadResolution), kind, left, right, node, diagnostics, resultKind, originalUserDefinedOperators);
        public ValueType UnaryOperatorOverloadResolution(Int32 kind, IOperation operand, CSharpSyntaxNode node, Object diagnostics, Object resultKind, Object originalUserDefinedOperators) => (ValueType)proxy.Invoke(nameof(UnaryOperatorOverloadResolution), kind, operand, node, diagnostics, resultKind, originalUserDefinedOperators);
        public Object FoldEnumBinaryOperator(CSharpSyntaxNode syntax, Int32 kind, IOperation left, IOperation right, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldEnumBinaryOperator), syntax, kind, left, right, diagnostics);
        public Object FoldBinaryOperator(CSharpSyntaxNode syntax, Int32 kind, IOperation left, IOperation right, SByte resultType, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldBinaryOperator), syntax, kind, left, right, resultType, diagnostics);
        public Object FoldBinaryOperator(CSharpSyntaxNode syntax, Int32 kind, IOperation left, IOperation right, SByte resultType, Object diagnostics, Object compoundStringLength) => (Object)proxy.Invoke(nameof(FoldBinaryOperator), syntax, kind, left, right, resultType, diagnostics, compoundStringLength);
        public IOperation BindIncrementOperator(CSharpSyntaxNode node, ExpressionSyntax operandSyntax, SyntaxToken operatorToken, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIncrementOperator), node, operandSyntax, operatorToken, diagnostics);
        public IOperation BindPointerIndirectionExpression(PrefixUnaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindPointerIndirectionExpression), node, diagnostics);
        public IOperation BindAddressOfExpression(PrefixUnaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAddressOfExpression), node, diagnostics);
        public Boolean IsNonMoveableVariable(IOperation expr, Object accessedLocalOrParameterOpt) => (Boolean)proxy.Invoke(nameof(IsNonMoveableVariable), expr, accessedLocalOrParameterOpt);
        public IOperation BindUnaryOperator(PrefixUnaryExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindUnaryOperator), node, diagnostics);
        public IOperation BindUnaryOperatorCore(CSharpSyntaxNode node, String operatorText, IOperation operand, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindUnaryOperatorCore), node, operatorText, operand, diagnostics);
        public Object FoldEnumUnaryOperator(CSharpSyntaxNode syntax, Int32 kind, IOperation operand, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldEnumUnaryOperator), syntax, kind, operand, diagnostics);
        public IOperation BindIndexedPropertyAccess(SyntaxNode syntax, IOperation receiverOpt, ImmutableArray<ISymbol> propertyGroup, Object arguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIndexedPropertyAccess), syntax, receiverOpt, propertyGroup, arguments, diagnostics);
        public IOperation BindDynamicIndexer(SyntaxNode syntax, IOperation receiverOpt, Object arguments, ImmutableArray<ISymbol> applicableProperties, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDynamicIndexer), syntax, receiverOpt, arguments, applicableProperties, diagnostics);
        public IOperation BindIndexerOrIndexedPropertyAccess(SyntaxNode syntax, IOperation receiverOpt, Object propertyGroup, Object analyzedArguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIndexerOrIndexedPropertyAccess), syntax, receiverOpt, propertyGroup, analyzedArguments, diagnostics);
        public IPropertySymbol CreateErrorPropertySymbol(ImmutableArray<ISymbol> propertyGroup) => (IPropertySymbol)proxy.Invoke(nameof(CreateErrorPropertySymbol), propertyGroup);
        public ValueType ResolveMethodGroup(IOperation node, Object analyzedArguments, Boolean isMethodGroupConversion, Object useSiteDiagnostics, Boolean inferWithDynamic = false) => (ValueType)proxy.Invoke(nameof(ResolveMethodGroup), node, analyzedArguments, isMethodGroupConversion, useSiteDiagnostics, inferWithDynamic);
        public ValueType ResolveMethodGroup(IOperation node, SyntaxNode expression, String methodName, Object analyzedArguments, Boolean isMethodGroupConversion, Object useSiteDiagnostics, Boolean inferWithDynamic = false, Boolean allowUnexpandedForm = true) => (ValueType)proxy.Invoke(nameof(ResolveMethodGroup), node, expression, methodName, analyzedArguments, isMethodGroupConversion, useSiteDiagnostics, inferWithDynamic, allowUnexpandedForm);
        public ValueType ResolveMethodGroupInternal(IOperation methodGroup, SyntaxNode expression, String methodName, Object analyzedArguments, Boolean isMethodGroupConversion, Object useSiteDiagnostics, Boolean inferWithDynamic = false, Boolean allowUnexpandedForm = true) => (ValueType)proxy.Invoke(nameof(ResolveMethodGroupInternal), methodGroup, expression, methodName, analyzedArguments, isMethodGroupConversion, useSiteDiagnostics, inferWithDynamic, allowUnexpandedForm);
        public ValueType ResolveDefaultMethodGroup(IOperation node, Object analyzedArguments, Boolean isMethodGroupConversion, Object useSiteDiagnostics, Boolean inferWithDynamic = false, Boolean allowUnexpandedForm = true) => (ValueType)proxy.Invoke(nameof(ResolveDefaultMethodGroup), node, analyzedArguments, isMethodGroupConversion, useSiteDiagnostics, inferWithDynamic, allowUnexpandedForm);
        public IConditionalAccessExpression BindConditionalAccessExpression(ConditionalAccessExpressionSyntax node, Object diagnostics) => (IConditionalAccessExpression)proxy.Invoke(nameof(BindConditionalAccessExpression), node, diagnostics);
        public Boolean ContainingMethodOrLambdaRequiresValue() => (Boolean)proxy.Invoke(nameof(ContainingMethodOrLambdaRequiresValue));
        public IConditionalAccessExpression GenerateBadConditionalAccessNodeError(ConditionalAccessExpressionSyntax node, IOperation receiver, IOperation access, Object diagnostics) => (IConditionalAccessExpression)proxy.Invoke(nameof(GenerateBadConditionalAccessNodeError), node, receiver, access, diagnostics);
        public IOperation BindMemberBindingExpression(MemberBindingExpressionSyntax node, Boolean invoked, Boolean indexed, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMemberBindingExpression), node, invoked, indexed, diagnostics);
        public IOperation BindElementBindingExpression(ElementBindingExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindElementBindingExpression), node, diagnostics);
        public IOperation GetReceiverForConditionalBinding(ExpressionSyntax binding, Object diagnostics) => (IOperation)proxy.Invoke(nameof(GetReceiverForConditionalBinding), binding, diagnostics);
        public IOperation BindConditionalAccessReceiver(ConditionalAccessExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConditionalAccessReceiver), node, diagnostics);
        public Object WithFlags(UInt32 flags) => (Object)proxy.Invoke(nameof(WithFlags), flags);
        public Object WithAdditionalFlags(UInt32 flags) => (Object)proxy.Invoke(nameof(WithAdditionalFlags), flags);
        public Object WithContainingMemberOrLambda(ISymbol containing) => (Object)proxy.Invoke(nameof(WithContainingMemberOrLambda), containing);
        public Object WithAdditionalFlagsAndContainingMemberOrLambda(UInt32 flags, ISymbol containing) => (Object)proxy.Invoke(nameof(WithAdditionalFlagsAndContainingMemberOrLambda), flags, containing);
        public Object WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) => (Object)proxy.Invoke(nameof(WithUnsafeRegionIfNecessary), modifiers);
        public Object WithCheckedOrUncheckedRegion(Boolean @checked) => (Object)proxy.Invoke(nameof(WithCheckedOrUncheckedRegion), @checked);
        public IOperation BindInterpolatedString(InterpolatedStringExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindInterpolatedString), node, diagnostics);
        public IOperation BindMethodGroup(ExpressionSyntax node, Boolean invoked, Boolean indexed, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMethodGroup), node, invoked, indexed, diagnostics);
        public IOperation MakeInvocationExpression(SyntaxNode node, IOperation receiver, String methodName, ImmutableArray<IOperation> args, Object diagnostics, SeparatedSyntaxList<TypeSyntax> typeArgsSyntax = default(SeparatedSyntaxList<TypeSyntax>), ImmutableArray<INamespaceOrTypeSymbol> typeArgs = default(ImmutableArray<INamespaceOrTypeSymbol>), CSharpSyntaxNode queryClause = null, Boolean allowFieldsAndProperties = false, Boolean allowUnexpandedForm = true) => (IOperation)proxy.Invoke(nameof(MakeInvocationExpression), node, receiver, methodName, args, diagnostics, typeArgsSyntax, typeArgs, queryClause, allowFieldsAndProperties, allowUnexpandedForm);
        public IOperation BindInvocationExpression(InvocationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindInvocationExpression), node, diagnostics);
        public IOperation BindArgListOperator(InvocationExpressionSyntax node, Object diagnostics, Object analyzedArguments) => (IOperation)proxy.Invoke(nameof(BindArgListOperator), node, diagnostics, analyzedArguments);
        public IOperation BindInvocationExpression(SyntaxNode node, SyntaxNode expression, String methodName, IOperation boundExpression, Object analyzedArguments, Object diagnostics, CSharpSyntaxNode queryClause = null, Boolean allowUnexpandedForm = true) => (IOperation)proxy.Invoke(nameof(BindInvocationExpression), node, expression, methodName, boundExpression, analyzedArguments, diagnostics, queryClause, allowUnexpandedForm);
        public IOperation BindDynamicInvocation(SyntaxNode node, IOperation expression, Object arguments, ImmutableArray<ISymbol> applicableMethods, Object diagnostics, CSharpSyntaxNode queryClause) => (IOperation)proxy.Invoke(nameof(BindDynamicInvocation), node, expression, arguments, applicableMethods, diagnostics, queryClause);
        public ImmutableArray<IOperation> BuildArgumentsForDynamicInvocation(Object arguments, Object diagnostics) => (ImmutableArray<IOperation>)proxy.Invoke(nameof(BuildArgumentsForDynamicInvocation), arguments, diagnostics);
        public IOperation BindDelegateInvocation(SyntaxNode node, SyntaxNode expression, String methodName, IOperation boundExpression, Object analyzedArguments, Object diagnostics, CSharpSyntaxNode queryClause, INamedTypeSymbol delegateType) => (IOperation)proxy.Invoke(nameof(BindDelegateInvocation), node, expression, methodName, boundExpression, analyzedArguments, diagnostics, queryClause, delegateType);
        public IOperation BindMethodGroupInvocation(SyntaxNode syntax, SyntaxNode expression, String methodName, IOperation methodGroup, Object analyzedArguments, Object diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm = true) => (IOperation)proxy.Invoke(nameof(BindMethodGroupInvocation), syntax, expression, methodName, methodGroup, analyzedArguments, diagnostics, queryClause, allowUnexpandedForm);
        public IOperation BindLocalFunctionInvocationWithDynamicArgument(SyntaxNode syntax, SyntaxNode expression, String methodName, IOperation boundMethodGroup, Object diagnostics, CSharpSyntaxNode queryClause, ValueType resolution) => (IOperation)proxy.Invoke(nameof(BindLocalFunctionInvocationWithDynamicArgument), syntax, expression, methodName, boundMethodGroup, diagnostics, queryClause, resolution);
        public ImmutableArray<ISymbol> GetCandidatesPassingFinalValidation(SyntaxNode syntax, Object overloadResolutionResult, IOperation receiverOpt, ImmutableArray<INamespaceOrTypeSymbol> typeArgumentsOpt, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(GetCandidatesPassingFinalValidation), syntax, overloadResolutionResult, receiverOpt, typeArgumentsOpt, diagnostics);
        public IInvocationExpression BindInvocationExpressionContinued(SyntaxNode node, SyntaxNode expression, String methodName, Object result, Object analyzedArguments, Object methodGroup, INamedTypeSymbol delegateTypeOpt, Object diagnostics, CSharpSyntaxNode queryClause = null) => (IInvocationExpression)proxy.Invoke(nameof(BindInvocationExpressionContinued), node, expression, methodName, result, analyzedArguments, methodGroup, delegateTypeOpt, diagnostics, queryClause);
        public IOperation ReplaceTypeOrValueReceiver(IOperation receiver, Boolean useType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(ReplaceTypeOrValueReceiver), receiver, useType, diagnostics);
        public IInvocationExpression CreateBadCall(SyntaxNode node, String name, IOperation receiver, ImmutableArray<ISymbol> methods, Byte resultKind, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Object analyzedArguments, Boolean invokedAsExtensionMethod, Boolean isDelegate) => (IInvocationExpression)proxy.Invoke(nameof(CreateBadCall), node, name, receiver, methods, resultKind, typeArguments, analyzedArguments, invokedAsExtensionMethod, isDelegate);
        public IInvocationExpression CreateBadCall(SyntaxNode node, IOperation expr, Byte resultKind, Object analyzedArguments) => (IInvocationExpression)proxy.Invoke(nameof(CreateBadCall), node, expr, resultKind, analyzedArguments);
        public Boolean TryBindNameofOperator(InvocationExpressionSyntax node, Object diagnostics, Object result) => (Boolean)proxy.Invoke(nameof(TryBindNameofOperator), node, diagnostics, result);
        public IOperation BindNameofOperatorInternal(InvocationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNameofOperatorInternal), node, diagnostics);
        public void EnsureNameofExpressionSymbols(IOperation methodGroup, Object diagnostics) => proxy.Invoke(nameof(EnsureNameofExpressionSymbols), methodGroup, diagnostics);
        public Boolean CheckSyntaxForNameofArgument(ExpressionSyntax argument, Object name, Object diagnostics, Boolean top = true) => (Boolean)proxy.Invoke(nameof(CheckSyntaxForNameofArgument), argument, name, diagnostics, top);
        public Boolean InvocableNameofInScope() => (Boolean)proxy.Invoke(nameof(InvocableNameofInScope));
        public Tuple<ImmutableArray<Byte>, ImmutableArray<ISymbol>, ImmutableArray<String>, Boolean> AnalyzeAnonymousFunction(CSharpSyntaxNode syntax, Object diagnostics) => (Tuple<ImmutableArray<Byte>, ImmutableArray<ISymbol>, ImmutableArray<String>, Boolean>)proxy.Invoke(nameof(AnalyzeAnonymousFunction), syntax, diagnostics);
        public void CheckParanthesizedLambdaParameters(SeparatedSyntaxList<ParameterSyntax> parameterSyntaxList, Object diagnostics) => proxy.Invoke(nameof(CheckParanthesizedLambdaParameters), parameterSyntaxList, diagnostics);
        public IUnboundLambdaExpression BindAnonymousFunction(CSharpSyntaxNode syntax, Object diagnostics) => (IUnboundLambdaExpression)proxy.Invoke(nameof(BindAnonymousFunction), syntax, diagnostics);
        public void LookupSymbolsSimpleName(Object result, INamespaceOrTypeSymbol qualifierOpt, String plainName, Int32 arity, Object basesBeingResolved, Int32 options, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupSymbolsSimpleName), result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, useSiteDiagnostics);
        public void LookupExtensionMethods(Object result, String name, Int32 arity, Int32 options, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupExtensionMethods), result, name, arity, options, useSiteDiagnostics);
        public Object LookupSymbolsWithFallback(Object result, String name, Int32 arity, Object useSiteDiagnostics, Object basesBeingResolved = null, Int32 options = 0) => (Object)proxy.Invoke(nameof(LookupSymbolsWithFallback), result, name, arity, useSiteDiagnostics, basesBeingResolved, options);
        public Object LookupSymbolsInternal(Object result, String name, Int32 arity, Object basesBeingResolved, Int32 options, Boolean diagnose, Object useSiteDiagnostics) => (Object)proxy.Invoke(nameof(LookupSymbolsInternal), result, name, arity, basesBeingResolved, options, diagnose, useSiteDiagnostics);
        public void LookupSymbolsInSingleBinder(Object result, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupSymbolsInSingleBinder), result, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupSymbolsOrMembersInternal(Object result, INamespaceOrTypeSymbol qualifierOpt, String name, Int32 arity, Object basesBeingResolved, Int32 options, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupSymbolsOrMembersInternal), result, qualifierOpt, name, arity, basesBeingResolved, options, diagnose, useSiteDiagnostics);
        public void LookupMembersWithFallback(Object result, INamespaceOrTypeSymbol nsOrType, String name, Int32 arity, Object useSiteDiagnostics, Object basesBeingResolved = null, Int32 options = 0) => proxy.Invoke(nameof(LookupMembersWithFallback), result, nsOrType, name, arity, useSiteDiagnostics, basesBeingResolved, options);
        public void LookupMembersInternal(Object result, INamespaceOrTypeSymbol nsOrType, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInternal), result, nsOrType, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupMembersInType(Object result, ITypeSymbol type, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInType), result, type, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupMembersInErrorType(Object result, IErrorTypeSymbol errorType, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInErrorType), result, errorType, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupMembersInSubmissions(Object result, ITypeSymbol submissionClass, String name, Int32 arity, Object basesBeingResolved, Int32 options, Object originalBinder, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupMembersInSubmissions), result, submissionClass, name, arity, basesBeingResolved, options, originalBinder, diagnose, useSiteDiagnostics);
        public void LookupExtensionMethodsInSingleBinder(ValueType scope, Object result, String name, Int32 arity, Int32 options, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupExtensionMethodsInSingleBinder), scope, result, name, arity, options, useSiteDiagnostics);
        public void LookupAttributeType(Object result, INamespaceOrTypeSymbol qualifierOpt, String name, Int32 arity, Object basesBeingResolved, Int32 options, Boolean diagnose, Object useSiteDiagnostics) => proxy.Invoke(nameof(LookupAttributeType), result, qualifierOpt, name, arity, basesBeingResolved, options, diagnose, useSiteDiagnostics);
        public Boolean IsAmbiguousResult(Object result, Object resultSymbol) => (Boolean)proxy.Invoke(nameof(IsAmbiguousResult), result, resultSymbol);
        public ISymbol ResolveMultipleSymbolsInAttributeTypeLookup(Object symbols) => (ISymbol)proxy.Invoke(nameof(ResolveMultipleSymbolsInAttributeTypeLookup), symbols);
        public Boolean IsSingleViableAttributeType(Object result, Object symbol) => (Boolean)proxy.Invoke(nameof(IsSingleViableAttributeType), result, symbol);
        public ValueType GenerateNonViableAttributeTypeResult(ISymbol symbol, Object diagInfo, Boolean diagnose) => (ValueType)proxy.Invoke(nameof(GenerateNonViableAttributeTypeResult), symbol, diagInfo, diagnose);
        public IOperation BindArrayCreationExpression(ArrayCreationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindArrayCreationExpression), node, diagnostics);
        public IOperation BindImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindImplicitArrayCreationExpression), node, diagnostics);
        public ImmutableArray<IOperation> BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, Object diagnostics, Int32 dimension, Int32 rank) => (ImmutableArray<IOperation>)proxy.Invoke(nameof(BindArrayInitializerExpressions), initializer, diagnostics, dimension, rank);
        public void BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, Object exprBuilder, Object diagnostics, Int32 dimension, Int32 rank) => proxy.Invoke(nameof(BindArrayInitializerExpressions), initializer, exprBuilder, diagnostics, dimension, rank);
        public IOperation ConvertAndBindArrayInitialization(Object diagnostics, InitializerExpressionSyntax node, IArrayTypeSymbol type, Int32?[] knownSizes, Int32 dimension, ImmutableArray<IOperation> boundInitExpr, Object boundInitExprIndex) => (IOperation)proxy.Invoke(nameof(ConvertAndBindArrayInitialization), diagnostics, node, type, knownSizes, dimension, boundInitExpr, boundInitExprIndex);
        public IOperation BindArrayInitializerList(Object diagnostics, InitializerExpressionSyntax node, IArrayTypeSymbol type, Int32?[] knownSizes, Int32 dimension, ImmutableArray<IOperation> boundInitExprOpt = default(ImmutableArray<IOperation>)) => (IOperation)proxy.Invoke(nameof(BindArrayInitializerList), diagnostics, node, type, knownSizes, dimension, boundInitExprOpt);
        public IOperation BindUnexpectedArrayInitializer(InitializerExpressionSyntax node, Object diagnostics, Int32 errorCode, CSharpSyntaxNode errorNode = null) => (IOperation)proxy.Invoke(nameof(BindUnexpectedArrayInitializer), node, diagnostics, errorCode, errorNode);
        public IArrayCreationExpression BindArrayCreationWithInitializer(Object diagnostics, ExpressionSyntax creationSyntax, InitializerExpressionSyntax initSyntax, IArrayTypeSymbol type, ImmutableArray<IOperation> sizes, ImmutableArray<IOperation> boundInitExprOpt = default(ImmutableArray<IOperation>)) => (IArrayCreationExpression)proxy.Invoke(nameof(BindArrayCreationWithInitializer), diagnostics, creationSyntax, initSyntax, type, sizes, boundInitExprOpt);
        public IOperation BindStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindStackAllocArrayCreationExpression), node, diagnostics);
        public IOperation BindConstructorInitializer(ArgumentListSyntax initializerArgumentListOpt, IMethodSymbol constructor, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConstructorInitializer), initializerArgumentListOpt, constructor, diagnostics);
        public IOperation BindConstructorInitializerCore(ArgumentListSyntax initializerArgumentListOpt, IMethodSymbol constructor, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindConstructorInitializerCore), initializerArgumentListOpt, constructor, diagnostics);
        public IOperation BindObjectCreationExpression(ObjectCreationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindObjectCreationExpression), node, diagnostics);
        public IOperation BindDelegateCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol type, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDelegateCreationExpression), node, type, diagnostics);
        public IOperation BindClassCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol type, String typeName, IOperation boundInitializerOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindClassCreationExpression), node, type, typeName, boundInitializerOpt, diagnostics);
        public IOperation MakeBadExpressionForObjectCreation(ObjectCreationExpressionSyntax node, INamedTypeSymbol type, IOperation boundInitializerOpt, Object analyzedArguments) => (IOperation)proxy.Invoke(nameof(MakeBadExpressionForObjectCreation), node, type, boundInitializerOpt, analyzedArguments);
        public IOperation BindInitializerExpressionOrValue(ExpressionSyntax syntax, ITypeSymbol type, SyntaxNode typeSyntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindInitializerExpressionOrValue), syntax, type, typeSyntax, diagnostics);
        public IOperation BindObjectInitializerExpression(InitializerExpressionSyntax initializerSyntax, ITypeSymbol initializerType, Object diagnostics, IInstanceReferenceExpression implicitReceiver) => (IOperation)proxy.Invoke(nameof(BindObjectInitializerExpression), initializerSyntax, initializerType, diagnostics, implicitReceiver);
        public IOperation BindObjectInitializerMemberAssignment(ExpressionSyntax memberInitializer, ITypeSymbol initializerType, Object objectInitializerMemberBinder, Object diagnostics, IInstanceReferenceExpression implicitReceiver) => (IOperation)proxy.Invoke(nameof(BindObjectInitializerMemberAssignment), memberInitializer, initializerType, objectInitializerMemberBinder, diagnostics, implicitReceiver);
        public IOperation BindObjectInitializerMember(AssignmentExpressionSyntax namedAssignment, IInstanceReferenceExpression implicitReceiver, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindObjectInitializerMember), namedAssignment, implicitReceiver, diagnostics);
        public IOperation BadObjectInitializerMemberAccess(IOperation boundMember, IInstanceReferenceExpression implicitReceiver, ExpressionSyntax memberNameSyntax, Object diagnostics, Byte valueKind, Boolean suppressErrors) => (IOperation)proxy.Invoke(nameof(BadObjectInitializerMemberAccess), boundMember, implicitReceiver, memberNameSyntax, diagnostics, valueKind, suppressErrors);
        public IOperation BindCollectionInitializerExpression(InitializerExpressionSyntax initializerSyntax, ITypeSymbol initializerType, Object diagnostics, IInstanceReferenceExpression implicitReceiver) => (IOperation)proxy.Invoke(nameof(BindCollectionInitializerExpression), initializerSyntax, initializerType, diagnostics, implicitReceiver);
        public Boolean CollectionInitializerTypeImplementsIEnumerable(ITypeSymbol initializerType, CSharpSyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CollectionInitializerTypeImplementsIEnumerable), initializerType, node, diagnostics);
        public IOperation BindCollectionInitializerElement(ExpressionSyntax elementInitializer, ITypeSymbol initializerType, Boolean hasEnumerableInitializerType, Object collectionInitializerAddMethodBinder, Object diagnostics, IInstanceReferenceExpression implicitReceiver) => (IOperation)proxy.Invoke(nameof(BindCollectionInitializerElement), elementInitializer, initializerType, hasEnumerableInitializerType, collectionInitializerAddMethodBinder, diagnostics, implicitReceiver);
        public IOperation BindComplexElementInitializerExpression(InitializerExpressionSyntax elementInitializer, Object diagnostics, Boolean hasEnumerableInitializerType, Object collectionInitializerAddMethodBinder = null, IInstanceReferenceExpression implicitReceiver = null) => (IOperation)proxy.Invoke(nameof(BindComplexElementInitializerExpression), elementInitializer, diagnostics, hasEnumerableInitializerType, collectionInitializerAddMethodBinder, implicitReceiver);
        public IOperation BindUnexpectedComplexElementInitializer(InitializerExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindUnexpectedComplexElementInitializer), node, diagnostics);
        public IOperation BindCollectionInitializerElementAddMethod(ExpressionSyntax elementInitializer, ImmutableArray<IOperation> boundElementInitializerExpressions, Boolean hasEnumerableInitializerType, Object collectionInitializerAddMethodBinder, Object diagnostics, IInstanceReferenceExpression implicitReceiver) => (IOperation)proxy.Invoke(nameof(BindCollectionInitializerElementAddMethod), elementInitializer, boundElementInitializerExpressions, hasEnumerableInitializerType, collectionInitializerAddMethodBinder, diagnostics, implicitReceiver);
        public ImmutableArray<ISymbol> FilterInaccessibleConstructors(ImmutableArray<ISymbol> constructors, Boolean allowProtectedConstructorsOfBaseType, Object useSiteDiagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(FilterInaccessibleConstructors), constructors, allowProtectedConstructorsOfBaseType, useSiteDiagnostics);
        public Boolean IsConstructorAccessible(IMethodSymbol constructor, Object useSiteDiagnostics, Boolean allowProtectedConstructorsOfBaseType = false) => (Boolean)proxy.Invoke(nameof(IsConstructorAccessible), constructor, useSiteDiagnostics, allowProtectedConstructorsOfBaseType);
        public IOperation BindClassCreationExpression(CSharpSyntaxNode node, String typeName, CSharpSyntaxNode typeNode, INamedTypeSymbol type, Object analyzedArguments, Object diagnostics, IOperation boundInitializerOpt = null) => (IOperation)proxy.Invoke(nameof(BindClassCreationExpression), node, typeName, typeNode, type, analyzedArguments, diagnostics, boundInitializerOpt);
        public IOperation BindInterfaceCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol type, IOperation boundInitializerOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindInterfaceCreationExpression), node, type, boundInitializerOpt, diagnostics);
        public IOperation BindBadInterfaceCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol type, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindBadInterfaceCreationExpression), node, type, diagnostics);
        public IOperation BindComImportCoClassCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol interfaceType, INamedTypeSymbol coClassType, IOperation boundInitializerOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindComImportCoClassCreationExpression), node, interfaceType, coClassType, boundInitializerOpt, diagnostics);
        public IOperation BindNoPiaObjectCreationExpression(ObjectCreationExpressionSyntax node, INamedTypeSymbol interfaceType, INamedTypeSymbol coClassType, IOperation boundInitializerOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNoPiaObjectCreationExpression), node, interfaceType, coClassType, boundInitializerOpt, diagnostics);
        public IOperation BindTypeParameterCreationExpression(ObjectCreationExpressionSyntax node, ITypeParameterSymbol typeParameter, IOperation boundInitializerOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindTypeParameterCreationExpression), node, typeParameter, boundInitializerOpt, diagnostics);
        public Boolean TryPerformConstructorOverloadResolution(INamedTypeSymbol typeContainingConstructors, Object analyzedArguments, String errorName, Location errorLocation, Boolean suppressResultDiagnostics, Object diagnostics, Object memberResolutionResult, Object candidateConstructors, Boolean allowProtectedConstructorsOfBaseType) => (Boolean)proxy.Invoke(nameof(TryPerformConstructorOverloadResolution), typeContainingConstructors, analyzedArguments, errorName, errorLocation, suppressResultDiagnostics, diagnostics, memberResolutionResult, candidateConstructors, allowProtectedConstructorsOfBaseType);
        public ImmutableArray<ISymbol> GetAccessibleConstructorsForOverloadResolution(INamedTypeSymbol type, Object useSiteDiagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(GetAccessibleConstructorsForOverloadResolution), type, useSiteDiagnostics);
        public ImmutableArray<ISymbol> GetAccessibleConstructorsForOverloadResolution(INamedTypeSymbol type, Boolean allowProtectedConstructorsOfBaseType, Object allInstanceConstructors, Object useSiteDiagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(GetAccessibleConstructorsForOverloadResolution), type, allowProtectedConstructorsOfBaseType, allInstanceConstructors, useSiteDiagnostics);
        public ILiteralExpression BindLiteralConstant(LiteralExpressionSyntax node, Object diagnostics) => (ILiteralExpression)proxy.Invoke(nameof(BindLiteralConstant), node, diagnostics);
        public IOperation BindCheckedExpression(CheckedExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCheckedExpression), node, diagnostics);
        public IOperation BindMemberAccess(MemberAccessExpressionSyntax node, Boolean invoked, Boolean indexed, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMemberAccess), node, invoked, indexed, diagnostics);
        public IOperation BindLeftOfPotentialColorColorMemberAccess(ExpressionSyntax left, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindLeftOfPotentialColorColorMemberAccess), left, diagnostics);
        public Boolean IsUsingAliasInScope(String name) => (Boolean)proxy.Invoke(nameof(IsUsingAliasInScope), name);
        public IOperation BindDynamicMemberAccess(ExpressionSyntax node, IOperation boundLeft, SimpleNameSyntax right, Boolean invoked, Boolean indexed, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDynamicMemberAccess), node, boundLeft, right, invoked, indexed, diagnostics);
        public IOperation BindMemberAccessWithBoundLeft(ExpressionSyntax node, IOperation boundLeft, SimpleNameSyntax right, SyntaxToken operatorToken, Boolean invoked, Boolean indexed, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMemberAccessWithBoundLeft), node, boundLeft, right, operatorToken, invoked, indexed, diagnostics);
        public IOperation MakeMemberAccessValue(IOperation expr, Object diagnostics) => (IOperation)proxy.Invoke(nameof(MakeMemberAccessValue), expr, diagnostics);
        public IOperation BindInstanceMemberAccess(SyntaxNode node, SyntaxNode right, IOperation boundLeft, String rightName, Int32 rightArity, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Boolean invoked, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindInstanceMemberAccess), node, right, boundLeft, rightName, rightArity, typeArgumentsSyntax, typeArguments, invoked, diagnostics);
        public void BindMemberAccessReportError(IOperation node, Object diagnostics) => proxy.Invoke(nameof(BindMemberAccessReportError), node, diagnostics);
        public void BindMemberAccessReportError(SyntaxNode node, SyntaxNode name, String plainName, IOperation boundLeft, Object lookupError, Object diagnostics) => proxy.Invoke(nameof(BindMemberAccessReportError), node, name, plainName, boundLeft, lookupError, diagnostics);
        public Boolean WouldUsingSystemFindExtension(ITypeSymbol receiver, String methodName) => (Boolean)proxy.Invoke(nameof(WouldUsingSystemFindExtension), receiver, methodName);
        public Boolean ImplementsWinRTAsyncInterface(ITypeSymbol type) => (Boolean)proxy.Invoke(nameof(ImplementsWinRTAsyncInterface), type);
        public Boolean IsWinRTAsyncInterface(ITypeSymbol type) => (Boolean)proxy.Invoke(nameof(IsWinRTAsyncInterface), type);
        public IOperation BindMemberAccessBadResult(IOperation node) => (IOperation)proxy.Invoke(nameof(BindMemberAccessBadResult), node);
        public IOperation BindMemberAccessBadResult(SyntaxNode node, String nameString, IOperation boundLeft, Object lookupError, ImmutableArray<ISymbol> symbols, Byte lookupKind) => (IOperation)proxy.Invoke(nameof(BindMemberAccessBadResult), node, nameString, boundLeft, lookupError, symbols, lookupKind);
        public ITypeSymbol GetNonMethodMemberType(ISymbol symbolOpt) => (ITypeSymbol)proxy.Invoke(nameof(GetNonMethodMemberType), symbolOpt);
        public IOperation BindMemberOfType(SyntaxNode node, SyntaxNode right, String plainName, Int32 arity, IOperation left, SeparatedSyntaxList<TypeSyntax> typeArgumentsSyntax, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Object lookupResult, Int32 methodGroupFlags, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMemberOfType), node, right, plainName, arity, left, typeArgumentsSyntax, typeArguments, lookupResult, methodGroupFlags, diagnostics);
        public ValueType BindExtensionMethod(SyntaxNode expression, String methodName, Object analyzedArguments, IOperation left, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Boolean isMethodGroupConversion) => (ValueType)proxy.Invoke(nameof(BindExtensionMethod), expression, methodName, analyzedArguments, left, typeArguments, isMethodGroupConversion);
        public void PopulateExtensionMethodsFromSingleBinder(ValueType scope, Object methodGroup, SyntaxNode node, IOperation left, String rightName, ImmutableArray<INamespaceOrTypeSymbol> typeArguments, Object diagnostics) => proxy.Invoke(nameof(PopulateExtensionMethodsFromSingleBinder), scope, methodGroup, node, left, rightName, typeArguments, diagnostics);
        public IOperation BindFieldAccess(SyntaxNode node, IOperation receiver, IFieldSymbol fieldSymbol, Object diagnostics, Byte resultKind, Boolean hasErrors) => (IOperation)proxy.Invoke(nameof(BindFieldAccess), node, receiver, fieldSymbol, diagnostics, resultKind, hasErrors);
        public Boolean InEnumMemberInitializer() => (Boolean)proxy.Invoke(nameof(InEnumMemberInitializer));
        public IOperation BindPropertyAccess(SyntaxNode node, IOperation receiver, IPropertySymbol propertySymbol, Object diagnostics, Byte lookupResult, Boolean hasErrors) => (IOperation)proxy.Invoke(nameof(BindPropertyAccess), node, receiver, propertySymbol, diagnostics, lookupResult, hasErrors);
        public IOperation BindEventAccess(SyntaxNode node, IOperation receiver, IEventSymbol eventSymbol, Object diagnostics, Byte lookupResult, Boolean hasErrors) => (IOperation)proxy.Invoke(nameof(BindEventAccess), node, receiver, eventSymbol, diagnostics, lookupResult, hasErrors);
        public Boolean CheckInstanceOrStatic(SyntaxNode node, IOperation receiver, ISymbol symbol, Object resultKind, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckInstanceOrStatic), node, receiver, symbol, resultKind, diagnostics);
        public ISymbol GetSymbolOrMethodOrPropertyGroup(Object result, SyntaxNode node, String plainName, Int32 arity, Object methodOrPropertyGroup, Object diagnostics, Object wasError) => (ISymbol)proxy.Invoke(nameof(GetSymbolOrMethodOrPropertyGroup), result, node, plainName, arity, methodOrPropertyGroup, diagnostics, wasError);
        public IOperation BindElementAccess(ElementAccessExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindElementAccess), node, diagnostics);
        public IOperation BindElementAccess(ExpressionSyntax node, IOperation receiver, BracketedArgumentListSyntax argumentList, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindElementAccess), node, receiver, argumentList, diagnostics);
        public IOperation BindElementOrIndexerAccess(ExpressionSyntax node, IOperation expr, Object analyzedArguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindElementOrIndexerAccess), node, expr, analyzedArguments, diagnostics);
        public IOperation BadIndexerExpression(ExpressionSyntax node, IOperation expr, Object analyzedArguments, Object errorOpt, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BadIndexerExpression), node, expr, analyzedArguments, errorOpt, diagnostics);
        public IOperation BindElementAccessCore(ExpressionSyntax node, IOperation expr, Object arguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindElementAccessCore), node, expr, arguments, diagnostics);
        public IOperation BindArrayAccess(ExpressionSyntax node, IOperation expr, Object arguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindArrayAccess), node, expr, arguments, diagnostics);
        public IOperation ConvertToArrayIndex(IOperation index, SyntaxNode node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(ConvertToArrayIndex), index, node, diagnostics);
        public IOperation TryImplicitConversionToArrayIndex(IOperation expr, SByte specialType, SyntaxNode node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(TryImplicitConversionToArrayIndex), expr, specialType, node, diagnostics);
        public IOperation BindPointerElementAccess(ExpressionSyntax node, IOperation expr, Object analyzedArguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindPointerElementAccess), node, expr, analyzedArguments, diagnostics);
        public IOperation BindIndexerAccess(ExpressionSyntax node, IOperation expr, Object analyzedArguments, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIndexerAccess), node, expr, analyzedArguments, diagnostics);
        public IOperation BindIndexedPropertyAccess(IOperation propertyGroup, Boolean mustHaveAllOptionalParameters, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIndexedPropertyAccess), propertyGroup, mustHaveAllOptionalParameters, diagnostics);
        public IInvalidExpression BadExpression(SyntaxNode syntax) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax);
        public IInvalidExpression BadExpression(SyntaxNode syntax, IOperation childNode) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, childNode);
        public IInvalidExpression BadExpression(SyntaxNode syntax, ImmutableArray<IOperation> childNodes) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, childNodes);
        public IInvalidExpression BadExpression(SyntaxNode syntax, Byte lookupResultKind) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, lookupResultKind);
        public IInvalidExpression BadExpression(SyntaxNode syntax, Byte lookupResultKind, IOperation childNode) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, lookupResultKind, childNode);
        public IInvalidExpression BadExpression(SyntaxNode syntax, Byte resultKind, ImmutableArray<ISymbol> symbols) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, resultKind, symbols);
        public IInvalidExpression BadExpression(SyntaxNode syntax, Byte resultKind, ImmutableArray<ISymbol> symbols, IOperation childNode) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, resultKind, symbols, childNode);
        public IInvalidExpression BadExpression(SyntaxNode syntax, Byte resultKind, ImmutableArray<ISymbol> symbols, ImmutableArray<IOperation> childNodes) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), syntax, resultKind, symbols, childNodes);
        public IOperation ToBadExpression(IOperation expr, Byte resultKind = 0) => (IOperation)proxy.Invoke(nameof(ToBadExpression), expr, resultKind);
        public ITypeSymbol CreateErrorType(String name = "") => (ITypeSymbol)proxy.Invoke(nameof(CreateErrorType), name);
        public IOperation BindValue(ExpressionSyntax node, Object diagnostics, Byte valueKind) => (IOperation)proxy.Invoke(nameof(BindValue), node, diagnostics, valueKind);
        public IOperation BindValueAllowArgList(ExpressionSyntax node, Object diagnostics, Byte valueKind) => (IOperation)proxy.Invoke(nameof(BindValueAllowArgList), node, diagnostics, valueKind);
        public IOperation BindVariableOrAutoPropInitializer(EqualsValueClauseSyntax initializerOpt, Byte refKind, ITypeSymbol varType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindVariableOrAutoPropInitializer), initializerOpt, refKind, varType, diagnostics);
        public Object CreateBinderForParameterDefaultValue(IParameterSymbol parameter, EqualsValueClauseSyntax defaultValueSyntax) => (Object)proxy.Invoke(nameof(CreateBinderForParameterDefaultValue), parameter, defaultValueSyntax);
        public IOperation BindParameterDefaultValue(EqualsValueClauseSyntax defaultValueSyntax, ITypeSymbol parameterType, Object diagnostics, Object valueBeforeConversion) => (IOperation)proxy.Invoke(nameof(BindParameterDefaultValue), defaultValueSyntax, parameterType, diagnostics, valueBeforeConversion);
        public IOperation BindEnumConstantInitializer(IFieldSymbol symbol, EqualsValueClauseSyntax equalsValueSyntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindEnumConstantInitializer), symbol, equalsValueSyntax, diagnostics);
        public IOperation BindExpression(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindExpression), node, diagnostics);
        public IOperation BindExpression(ExpressionSyntax node, Object diagnostics, Boolean invoked, Boolean indexed) => (IOperation)proxy.Invoke(nameof(BindExpression), node, diagnostics, invoked, indexed);
        public IOperation BindExpressionAllowArgList(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindExpressionAllowArgList), node, diagnostics);
        public void VerifyUnchecked(ExpressionSyntax node, Object diagnostics, IOperation expr) => proxy.Invoke(nameof(VerifyUnchecked), node, diagnostics, expr);
        public IOperation BindExpressionInternal(ExpressionSyntax node, Object diagnostics, Boolean invoked, Boolean indexed) => (IOperation)proxy.Invoke(nameof(BindExpressionInternal), node, diagnostics, invoked, indexed);
        public IOperation BindRefExpression(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindRefExpression), node, diagnostics);
        public IOperation BindRefType(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindRefType), node, diagnostics);
        public IOperation BindThrowExpression(ThrowExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindThrowExpression), node, diagnostics);
        public IOperation BindDeclarationExpression(DeclarationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeclarationExpression), node, diagnostics);
        public IOperation BindDeclarationVariables(ITypeSymbol declType, VariableDesignationSyntax node, CSharpSyntaxNode syntax, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDeclarationVariables), declType, node, syntax, diagnostics);
        public IOperation BindTupleExpression(TupleExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindTupleExpression), node, diagnostics);
        public IOperation BindRefValue(RefValueExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindRefValue), node, diagnostics);
        public IOperation BindMakeRef(MakeRefExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindMakeRef), node, diagnostics);
        public IOperation BindRefType(RefTypeExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindRefType), node, diagnostics);
        public IOperation BindArgList(CSharpSyntaxNode node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindArgList), node, diagnostics);
        public IOperation BindQualifiedName(QualifiedNameSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindQualifiedName), node, diagnostics);
        public IOperation BindParenthesizedExpression(ExpressionSyntax innerExpression, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindParenthesizedExpression), innerExpression, diagnostics);
        public IOperation BindTypeOf(TypeOfExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindTypeOf), node, diagnostics);
        public IOperation BindSizeOf(SizeOfExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindSizeOf), node, diagnostics);
        public IOperation BindDefaultExpression(DefaultExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindDefaultExpression), node, diagnostics);
        public IOperation BindIdentifier(SimpleNameSyntax node, Boolean invoked, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindIdentifier), node, invoked, diagnostics);
        public IOperation SynthesizeMethodGroupReceiver(CSharpSyntaxNode syntax, Object members) => (IOperation)proxy.Invoke(nameof(SynthesizeMethodGroupReceiver), syntax, members);
        public Boolean IsBadLocalOrParameterCapture(ISymbol symbol, Byte refKind) => (Boolean)proxy.Invoke(nameof(IsBadLocalOrParameterCapture), symbol, refKind);
        public IOperation BindNonMethod(SimpleNameSyntax node, ISymbol symbol, Object diagnostics, Byte resultKind, Boolean isError) => (IOperation)proxy.Invoke(nameof(BindNonMethod), node, symbol, diagnostics, resultKind, isError);
        public IOperation BindRangeVariable(SimpleNameSyntax node, IRangeVariableSymbol qv, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindRangeVariable), node, qv, diagnostics);
        public IOperation SynthesizeReceiver(CSharpSyntaxNode node, ISymbol member, Object diagnostics) => (IOperation)proxy.Invoke(nameof(SynthesizeReceiver), node, member, diagnostics);
        public ISymbol ContainingMember() => (ISymbol)proxy.Invoke(nameof(ContainingMember));
        public IOperation TryBindInteractiveReceiver(CSharpSyntaxNode syntax, ISymbol currentMember, INamedTypeSymbol currentType, INamedTypeSymbol memberDeclaringType) => (IOperation)proxy.Invoke(nameof(TryBindInteractiveReceiver), syntax, currentMember, currentType, memberDeclaringType);
        public IOperation BindNamespaceOrTypeOrExpression(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNamespaceOrTypeOrExpression), node, diagnostics);
        public IOperation BindLabel(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindLabel), node, diagnostics);
        public IOperation BindNamespaceOrType(ExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNamespaceOrType), node, diagnostics);
        public IOperation BindNamespaceAlias(IdentifierNameSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNamespaceAlias), node, diagnostics);
        public IInstanceReferenceExpression BindThis(ThisExpressionSyntax node, Object diagnostics) => (IInstanceReferenceExpression)proxy.Invoke(nameof(BindThis), node, diagnostics);
        public IInstanceReferenceExpression ThisReference(CSharpSyntaxNode node, INamedTypeSymbol thisTypeOpt, Boolean hasErrors = false, Boolean wasCompilerGenerated = false) => (IInstanceReferenceExpression)proxy.Invoke(nameof(ThisReference), node, thisTypeOpt, hasErrors, wasCompilerGenerated);
        public Boolean IsRefOrOutThisParameterCaptured(SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(IsRefOrOutThisParameterCaptured), node, diagnostics);
        public IInstanceReferenceExpression BindBase(BaseExpressionSyntax node, Object diagnostics) => (IInstanceReferenceExpression)proxy.Invoke(nameof(BindBase), node, diagnostics);
        public IOperation BindCast(CastExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCast), node, diagnostics);
        public IOperation BindCastCore(ExpressionSyntax node, IOperation operand, ITypeSymbol targetType, Boolean wasCompilerGenerated, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindCastCore), node, operand, targetType, wasCompilerGenerated, diagnostics);
        public void GenerateExplicitConversionErrors(Object diagnostics, SyntaxNode syntax, Conversion conversion, IOperation operand, ITypeSymbol targetType) => proxy.Invoke(nameof(GenerateExplicitConversionErrors), diagnostics, syntax, conversion, operand, targetType);
        public void GenerateExplicitConversionErrorsForTupleLiteralArguments(Object diagnostics, ImmutableArray<IOperation> tupleArguments, ImmutableArray<INamespaceOrTypeSymbol> targetElementTypes) => proxy.Invoke(nameof(GenerateExplicitConversionErrorsForTupleLiteralArguments), diagnostics, tupleArguments, targetElementTypes);
        public IOperation BindExplicitNullableCastFromNonNullable(ExpressionSyntax node, IOperation operand, ITypeSymbol targetType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindExplicitNullableCastFromNonNullable), node, operand, targetType, diagnostics);
        public void BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, Object diagnostics, Object result, Boolean allowArglist = false, Boolean isDelegateCreation = false) => proxy.Invoke(nameof(BindArgumentsAndNames), argumentListOpt, diagnostics, result, allowArglist, isDelegateCreation);
        public void BindArgumentsAndNames(BracketedArgumentListSyntax argumentListOpt, Object diagnostics, Object result) => proxy.Invoke(nameof(BindArgumentsAndNames), argumentListOpt, diagnostics, result);
        public void BindArgumentsAndNames(SeparatedSyntaxList<ArgumentSyntax> arguments, Object diagnostics, Object result, Boolean allowArglist, Boolean isDelegateCreation = false) => proxy.Invoke(nameof(BindArgumentsAndNames), arguments, diagnostics, result, allowArglist, isDelegateCreation);
        public Boolean RefMustBeObeyed(Boolean isDelegateCreation, ArgumentSyntax argumentSyntax) => (Boolean)proxy.Invoke(nameof(RefMustBeObeyed), isDelegateCreation, argumentSyntax);
        public Boolean BindArgumentAndName(Object result, Object diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation = false) => (Boolean)proxy.Invoke(nameof(BindArgumentAndName), result, diagnostics, hadError, argumentSyntax, allowArglist, isDelegateCreation);
        public IOperation BindArgumentValue(Object diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, Byte refKind) => (IOperation)proxy.Invoke(nameof(BindArgumentValue), diagnostics, argumentSyntax, allowArglist, refKind);
        public IOperation BindOutDeclarationArgument(DeclarationExpressionSyntax declarationExpression, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindOutDeclarationArgument), declarationExpression, diagnostics);
        public IOperation BindOutVariableDeclarationArgument(DeclarationExpressionSyntax declarationExpression, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindOutVariableDeclarationArgument), declarationExpression, diagnostics);
        public IFieldSymbol LookupDeclaredField(SingleVariableDesignationSyntax variableDesignator) => (IFieldSymbol)proxy.Invoke(nameof(LookupDeclaredField), variableDesignator);
        public IFieldSymbol LookupDeclaredField(SyntaxNode node, String identifier) => (IFieldSymbol)proxy.Invoke(nameof(LookupDeclaredField), node, identifier);
        public Boolean BindArgumentAndName(Object result, Object diagnostics, Boolean hadError, CSharpSyntaxNode argumentSyntax, IOperation boundArgumentExpression, NameColonSyntax nameColonSyntax, Byte refKind) => (Boolean)proxy.Invoke(nameof(BindArgumentAndName), result, diagnostics, hadError, argumentSyntax, boundArgumentExpression, nameColonSyntax, refKind);
        public IOperation BindArgumentExpression(Object diagnostics, ExpressionSyntax argumentExpression, Byte refKind, Boolean allowArglist) => (IOperation)proxy.Invoke(nameof(BindArgumentExpression), diagnostics, argumentExpression, refKind, allowArglist);
        public void CoerceArguments(ValueType methodResult, Object arguments, Object diagnostics) => proxy.Invoke(nameof(CoerceArguments), methodResult, arguments, diagnostics);
        public AttributeData GetAttribute(IOperation boundAttribute, Object diagnostics) => (AttributeData)proxy.Invoke(nameof(GetAttribute), boundAttribute, diagnostics);
        public void ValidateTypeForAttributeParameters(ImmutableArray<ISymbol> parameters, CSharpSyntaxNode syntax, Object diagnostics, Object hasErrors) => proxy.Invoke(nameof(ValidateTypeForAttributeParameters), parameters, syntax, diagnostics, hasErrors);
        public Boolean IsAttributeConditionallyOmitted(INamedTypeSymbol attributeType, SyntaxTree syntaxTree, Object useSiteDiagnostics) => (Boolean)proxy.Invoke(nameof(IsAttributeConditionallyOmitted), attributeType, syntaxTree, useSiteDiagnostics);
        public ValueType BindAttributeArguments(AttributeArgumentListSyntax attributeArgumentList, INamedTypeSymbol attributeType, Object diagnostics) => (ValueType)proxy.Invoke(nameof(BindAttributeArguments), attributeArgumentList, attributeType, diagnostics);
        public IOperation BindNamedAttributeArgument(AttributeArgumentSyntax namedArgument, INamedTypeSymbol attributeType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindNamedAttributeArgument), namedArgument, attributeType, diagnostics);
        public ISymbol BindNamedAttributeArgumentName(AttributeArgumentSyntax namedArgument, INamedTypeSymbol attributeType, Object diagnostics, Object wasError, Object resultKind) => (ISymbol)proxy.Invoke(nameof(BindNamedAttributeArgumentName), namedArgument, attributeType, diagnostics, wasError, resultKind);
        public ITypeSymbol BindNamedAttributeArgumentType(AttributeArgumentSyntax namedArgument, ISymbol namedArgumentNameSymbol, INamedTypeSymbol attributeType, Object diagnostics) => (ITypeSymbol)proxy.Invoke(nameof(BindNamedAttributeArgumentType), namedArgument, namedArgumentNameSymbol, attributeType, diagnostics);
        public IMethodSymbol BindAttributeConstructor(AttributeSyntax node, INamedTypeSymbol attributeType, Object boundConstructorArguments, Object diagnostics, Object resultKind, Boolean suppressErrors, Object useSiteDiagnostics) => (IMethodSymbol)proxy.Invoke(nameof(BindAttributeConstructor), node, attributeType, boundConstructorArguments, diagnostics, resultKind, suppressErrors, useSiteDiagnostics);
        public ImmutableArray<TypedConstant> GetRewrittenAttributeConstructorArguments(Object constructorArgumentsSourceIndices, IMethodSymbol attributeConstructor, ImmutableArray<TypedConstant> constructorArgsArray, ImmutableArray<String> constructorArgumentNamesOpt, AttributeSyntax syntax, Object diagnostics, Object hasErrors) => (ImmutableArray<TypedConstant>)proxy.Invoke(nameof(GetRewrittenAttributeConstructorArguments), constructorArgumentsSourceIndices, attributeConstructor, constructorArgsArray, constructorArgumentNamesOpt, syntax, diagnostics, hasErrors);
        public TypedConstant GetMatchingNamedOrOptionalConstructorArgument(Object matchingArgumentIndex, ImmutableArray<TypedConstant> constructorArgsArray, ImmutableArray<String> constructorArgumentNamesOpt, IParameterSymbol parameter, Int32 startIndex, Int32 argumentsCount, Object argsConsumedCount, AttributeSyntax syntax, Object diagnostics) => (TypedConstant)proxy.Invoke(nameof(GetMatchingNamedOrOptionalConstructorArgument), matchingArgumentIndex, constructorArgsArray, constructorArgumentNamesOpt, parameter, startIndex, argumentsCount, argsConsumedCount, syntax, diagnostics);
        public TypedConstant GetDefaultValueArgument(IParameterSymbol parameter, AttributeSyntax syntax, Object diagnostics) => (TypedConstant)proxy.Invoke(nameof(GetDefaultValueArgument), parameter, syntax, diagnostics);
        public IOperation BindAwait(AwaitExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAwait), node, diagnostics);
        public IOperation BindAwait(IOperation expression, SyntaxNode node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAwait), expression, node, diagnostics);
        public Boolean CouldBeAwaited(IOperation expression) => (Boolean)proxy.Invoke(nameof(CouldBeAwaited), expression);
        public Boolean ReportBadAwaitWithoutAsync(SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportBadAwaitWithoutAsync), node, diagnostics);
        public Boolean ReportBadAwaitContext(SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(ReportBadAwaitContext), node, diagnostics);
        public Boolean GetAwaitableExpressionInfo(IOperation expression, Object getAwaiter, Object isCompleted, Object getResult, Object getAwaiterGetResultCall, SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(GetAwaitableExpressionInfo), expression, getAwaiter, isCompleted, getResult, getAwaiterGetResultCall, node, diagnostics);
        public Boolean GetGetAwaiterMethod(IOperation expression, SyntaxNode node, Object diagnostics, Object getAwaiterMethod, Object getAwaiterCall) => (Boolean)proxy.Invoke(nameof(GetGetAwaiterMethod), expression, node, diagnostics, getAwaiterMethod, getAwaiterCall);
        public Boolean GetIsCompletedProperty(ITypeSymbol awaiterType, SyntaxNode node, ITypeSymbol awaitedExpressionType, Object diagnostics, Object isCompletedProperty) => (Boolean)proxy.Invoke(nameof(GetIsCompletedProperty), awaiterType, node, awaitedExpressionType, diagnostics, isCompletedProperty);
        public Boolean AwaiterImplementsINotifyCompletion(ITypeSymbol awaiterType, SyntaxNode node, Object diagnostics) => (Boolean)proxy.Invoke(nameof(AwaiterImplementsINotifyCompletion), awaiterType, node, diagnostics);
        public Boolean GetGetResultMethod(IOperation awaiterExpression, SyntaxNode node, ITypeSymbol awaitedExpressionType, Object diagnostics, Object getResultMethod, Object getAwaiterGetResultCall) => (Boolean)proxy.Invoke(nameof(GetGetResultMethod), awaiterExpression, node, awaitedExpressionType, diagnostics, getResultMethod, getAwaiterGetResultCall);
        public ImmutableArray<Object> BindTypeParameterConstraintClauses(ISymbol containingSymbol, ImmutableArray<ITypeSymbol> typeParameters, SyntaxList<TypeParameterConstraintClauseSyntax> clauses, Object diagnostics) => (ImmutableArray<Object>)proxy.Invoke(nameof(BindTypeParameterConstraintClauses), containingSymbol, typeParameters, clauses, diagnostics);
        public Object BindTypeParameterConstraints(String name, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraintsSyntax, Object diagnostics) => (Object)proxy.Invoke(nameof(BindTypeParameterConstraints), name, constraintsSyntax, diagnostics);
        public IOperation CreateConversion(IOperation source, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateConversion), source, destination, diagnostics);
        public IOperation CreateConversion(IOperation source, Conversion conversion, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateConversion), source, conversion, destination, diagnostics);
        public IOperation CreateConversion(SyntaxNode syntax, IOperation source, Conversion conversion, Boolean isCast, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateConversion), syntax, source, conversion, isCast, destination, diagnostics);
        public IOperation CreateConversion(SyntaxNode syntax, IOperation source, Conversion conversion, Boolean isCast, Boolean wasCompilerGenerated, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateConversion), syntax, source, conversion, isCast, wasCompilerGenerated, destination, diagnostics);
        public IOperation CreateUserDefinedConversion(SyntaxNode syntax, IOperation source, Conversion conversion, Boolean isCast, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateUserDefinedConversion), syntax, source, conversion, isCast, destination, diagnostics);
        public IOperation CreateMethodGroupConversion(SyntaxNode syntax, IOperation source, Conversion conversion, Boolean isCast, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateMethodGroupConversion), syntax, source, conversion, isCast, destination, diagnostics);
        public IOperation CreateTupleLiteralConversion(SyntaxNode syntax, IOperation sourceTuple, Conversion conversion, Boolean isCast, ITypeSymbol destination, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CreateTupleLiteralConversion), syntax, sourceTuple, conversion, isCast, destination, diagnostics);
        public IOperation FixMethodGroupWithTypeOrValue(IOperation group, Conversion conversion, Object diagnostics) => (IOperation)proxy.Invoke(nameof(FixMethodGroupWithTypeOrValue), group, conversion, diagnostics);
        public Boolean MemberGroupFinalValidation(IOperation receiverOpt, IMethodSymbol methodSymbol, SyntaxNode node, Object diagnostics, Boolean invokedAsExtensionMethod) => (Boolean)proxy.Invoke(nameof(MemberGroupFinalValidation), receiverOpt, methodSymbol, node, diagnostics, invokedAsExtensionMethod);
        public Boolean MemberGroupFinalValidationAccessibilityChecks(IOperation receiverOpt, ISymbol memberSymbol, SyntaxNode node, Object diagnostics, Boolean invokedAsExtensionMethod) => (Boolean)proxy.Invoke(nameof(MemberGroupFinalValidationAccessibilityChecks), receiverOpt, memberSymbol, node, diagnostics, invokedAsExtensionMethod);
        public Boolean MethodGroupIsCompatibleWithDelegate(IOperation receiverOpt, Boolean isExtensionMethod, IMethodSymbol method, INamedTypeSymbol delegateType, Location errorLocation, Object diagnostics) => (Boolean)proxy.Invoke(nameof(MethodGroupIsCompatibleWithDelegate), receiverOpt, isExtensionMethod, method, delegateType, errorLocation, diagnostics);
        public Boolean MethodGroupConversionHasErrors(SyntaxNode syntax, Conversion conversion, IOperation receiverOpt, Boolean isExtensionMethod, INamedTypeSymbol delegateType, Object diagnostics) => (Boolean)proxy.Invoke(nameof(MethodGroupConversionHasErrors), syntax, conversion, receiverOpt, isExtensionMethod, delegateType, diagnostics);
        public Boolean MethodGroupConversionDoesNotExistOrHasErrors(IOperation boundMethodGroup, INamedTypeSymbol delegateType, Location delegateMismatchLocation, Object diagnostics, Object conversion) => (Boolean)proxy.Invoke(nameof(MethodGroupConversionDoesNotExistOrHasErrors), boundMethodGroup, delegateType, delegateMismatchLocation, diagnostics, conversion);
        public Object FoldConstantConversion(SyntaxNode syntax, IOperation source, Conversion conversion, ITypeSymbol destination, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldConstantConversion), syntax, source, conversion, destination, diagnostics);
        public Object FoldConstantNumericConversion(SyntaxNode syntax, Object sourceValue, ITypeSymbol destination, Object diagnostics) => (Object)proxy.Invoke(nameof(FoldConstantNumericConversion), syntax, sourceValue, destination, diagnostics);
        public ImmutableArray<ISymbol> BindCref(CrefSyntax syntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindCref), syntax, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindCrefInternal(CrefSyntax syntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindCrefInternal), syntax, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindTypeCref(TypeCrefSyntax syntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindTypeCref), syntax, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindQualifiedCref(QualifiedCrefSyntax syntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindQualifiedCref), syntax, ambiguityWinner, diagnostics);
        public INamespaceOrTypeSymbol BindNamespaceOrTypeSymbolInCref(TypeSyntax syntax) => (INamespaceOrTypeSymbol)proxy.Invoke(nameof(BindNamespaceOrTypeSymbolInCref), syntax);
        public ImmutableArray<ISymbol> BindMemberCref(MemberCrefSyntax syntax, INamespaceOrTypeSymbol containerOpt, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindMemberCref), syntax, containerOpt, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindNameMemberCref(NameMemberCrefSyntax syntax, INamespaceOrTypeSymbol containerOpt, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindNameMemberCref), syntax, containerOpt, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindIndexerMemberCref(IndexerMemberCrefSyntax syntax, INamespaceOrTypeSymbol containerOpt, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindIndexerMemberCref), syntax, containerOpt, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindOperatorMemberCref(OperatorMemberCrefSyntax syntax, INamespaceOrTypeSymbol containerOpt, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindOperatorMemberCref), syntax, containerOpt, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> BindConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax syntax, INamespaceOrTypeSymbol containerOpt, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindConversionOperatorMemberCref), syntax, containerOpt, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> ComputeSortedCrefMembers(CSharpSyntaxNode syntax, INamespaceOrTypeSymbol containerOpt, String memberName, Int32 arity, Boolean hasParameterList, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(ComputeSortedCrefMembers), syntax, containerOpt, memberName, arity, hasParameterList, diagnostics);
        public ImmutableArray<ISymbol> ComputeSortedCrefMembers(INamespaceOrTypeSymbol containerOpt, String memberName, Int32 arity, Boolean hasParameterList, Object useSiteDiagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(ComputeSortedCrefMembers), containerOpt, memberName, arity, hasParameterList, useSiteDiagnostics);
        public ImmutableArray<ISymbol> ProcessCrefMemberLookupResults(ImmutableArray<ISymbol> symbols, Int32 arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax typeArgumentListSyntax, BaseCrefParameterListSyntax parameterListSyntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(ProcessCrefMemberLookupResults), symbols, arity, memberSyntax, typeArgumentListSyntax, parameterListSyntax, ambiguityWinner, diagnostics);
        public ImmutableArray<ISymbol> ProcessParameterlessCrefMemberLookupResults(ImmutableArray<ISymbol> symbols, Int32 arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax typeArgumentListSyntax, Object ambiguityWinner, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(ProcessParameterlessCrefMemberLookupResults), symbols, arity, memberSyntax, typeArgumentListSyntax, ambiguityWinner, diagnostics);
        public void GetCrefOverloadResolutionCandidates(ImmutableArray<ISymbol> symbols, Int32 arity, TypeArgumentListSyntax typeArgumentListSyntax, Object candidates) => proxy.Invoke(nameof(GetCrefOverloadResolutionCandidates), symbols, arity, typeArgumentListSyntax, candidates);
        public ISymbol ConstructWithCrefTypeParameters(Int32 arity, TypeArgumentListSyntax typeArgumentListSyntax, ISymbol symbol) => (ISymbol)proxy.Invoke(nameof(ConstructWithCrefTypeParameters), arity, typeArgumentListSyntax, symbol);
        public ImmutableArray<ISymbol> BindCrefParameters(BaseCrefParameterListSyntax parameterListSyntax, Object diagnostics) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(BindCrefParameters), parameterListSyntax, diagnostics);
        public ITypeSymbol BindCrefParameterOrReturnType(TypeSyntax typeSyntax, MemberCrefSyntax memberCrefSyntax, Object diagnostics) => (ITypeSymbol)proxy.Invoke(nameof(BindCrefParameterOrReturnType), typeSyntax, memberCrefSyntax, diagnostics);
        public Boolean HasThis(Boolean isExplicit, Object inStaticContext) => (Boolean)proxy.Invoke(nameof(HasThis), isExplicit, inStaticContext);
        public Boolean IsUnboundTypeAllowed(GenericNameSyntax syntax) => (Boolean)proxy.Invoke(nameof(IsUnboundTypeAllowed), syntax);
        public Object GetBinder(SyntaxNode node) => (Object)proxy.Invoke(nameof(GetBinder), node);
        public ImmutableArray<ISymbol> GetDeclaredLocalsForScope(SyntaxNode scopeDesignator) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(GetDeclaredLocalsForScope), scopeDesignator);
        public ImmutableArray<ISymbol> GetDeclaredLocalFunctionsForScope(CSharpSyntaxNode scopeDesignator) => (ImmutableArray<ISymbol>)proxy.Invoke(nameof(GetDeclaredLocalFunctionsForScope), scopeDesignator);
        public ITypeSymbol GetIteratorElementType(YieldStatementSyntax node, Object diagnostics) => (ITypeSymbol)proxy.Invoke(nameof(GetIteratorElementType), node, diagnostics);
        public Object GetImports(Object basesBeingResolved) => (Object)proxy.Invoke(nameof(GetImports), basesBeingResolved);
        public void ReportDiagnosticsIfObsolete(Object diagnostics, ISymbol symbol, SyntaxNodeOrToken node, Boolean hasBaseReceiver) => proxy.Invoke(nameof(ReportDiagnosticsIfObsolete), diagnostics, symbol, node, hasBaseReceiver);
        public void ReportDiagnosticsIfObsolete(Object diagnostics, Conversion conversion, SyntaxNodeOrToken node, Boolean hasBaseReceiver) => proxy.Invoke(nameof(ReportDiagnosticsIfObsolete), diagnostics, conversion, node, hasBaseReceiver);
        public Boolean IsSymbolAccessibleConditional(ISymbol symbol, INamedTypeSymbol within, Object useSiteDiagnostics, ITypeSymbol throughTypeOpt = null) => (Boolean)proxy.Invoke(nameof(IsSymbolAccessibleConditional), symbol, within, useSiteDiagnostics, throughTypeOpt);
        public Boolean IsSymbolAccessibleConditional(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughTypeOpt, Object failedThroughTypeCheck, Object useSiteDiagnostics, Object basesBeingResolved = null) => (Boolean)proxy.Invoke(nameof(IsSymbolAccessibleConditional), symbol, within, throughTypeOpt, failedThroughTypeCheck, useSiteDiagnostics, basesBeingResolved);
        public IOperation WrapWithVariablesAndLocalFunctionsIfAny(CSharpSyntaxNode scopeDesignator, IOperation statement) => (IOperation)proxy.Invoke(nameof(WrapWithVariablesAndLocalFunctionsIfAny), scopeDesignator, statement);
        public String Dump() => (String)proxy.Invoke(nameof(Dump));
        public IOperation CheckValue(IOperation expr, Byte valueKind, Object diagnostics) => (IOperation)proxy.Invoke(nameof(CheckValue), expr, valueKind, diagnostics);
        public Boolean CheckValueKind(SyntaxNode node, IOperation expr, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckValueKind), node, expr, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckLocalValueKind(SyntaxNode node, ILocalReferenceExpression local, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckLocalValueKind), node, local, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckParameterValueKind(SyntaxNode node, IParameterReferenceExpression parameter, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckParameterValueKind), node, parameter, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckFieldValueKind(SyntaxNode node, IFieldReferenceExpression fieldAccess, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckFieldValueKind), node, fieldAccess, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckEventValueKind(IEventReferenceExpression boundEvent, Byte valueKind, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckEventValueKind), boundEvent, valueKind, diagnostics);
        public Boolean CheckIsValidReceiverForVariable(SyntaxNode node, IOperation receiver, Byte kind, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckIsValidReceiverForVariable), node, receiver, kind, diagnostics);
        public Boolean CheckCallValueKind(IInvocationExpression call, SyntaxNode node, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckCallValueKind), call, node, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckPropertyValueKind(SyntaxNode node, IOperation expr, Byte valueKind, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckPropertyValueKind), node, expr, valueKind, checkingReceiver, diagnostics);
        public Boolean CheckArgumentsReturnable(SyntaxNode syntax, ISymbol symbol, ImmutableArray<ISymbol> parameters, ImmutableArray<IOperation> args, ImmutableArray<Byte> argRefKinds, ImmutableArray<Int32> argToParamsOpt, Boolean checkingReceiver, Object diagnostics) => (Boolean)proxy.Invoke(nameof(CheckArgumentsReturnable), syntax, symbol, parameters, args, argRefKinds, argToParamsOpt, checkingReceiver, diagnostics);
        public IOperation BindAnonymousObjectCreation(AnonymousObjectCreationExpressionSyntax node, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAnonymousObjectCreation), node, diagnostics);
        public Boolean IsAnonymousTypesAllowed() => (Boolean)proxy.Invoke(nameof(IsAnonymousTypesAllowed));
        public ITypeSymbol GetAnonymousTypeFieldType(IOperation expression, CSharpSyntaxNode errorSyntax, Object diagnostics, Object hasError) => (ITypeSymbol)proxy.Invoke(nameof(GetAnonymousTypeFieldType), expression, errorSyntax, diagnostics, hasError);
        public AttributeData GetAttribute(AttributeSyntax node, INamedTypeSymbol boundAttributeType, Object diagnostics) => (AttributeData)proxy.Invoke(nameof(GetAttribute), node, boundAttributeType, diagnostics);
        public IOperation BindAttribute(AttributeSyntax node, INamedTypeSymbol attributeType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAttribute), node, attributeType, diagnostics);
        public Object SkipSemanticModelBinder() => (Object)proxy.Invoke(nameof(SkipSemanticModelBinder));
        public IOperation BindAttributeCore(AttributeSyntax node, INamedTypeSymbol attributeType, Object diagnostics) => (IOperation)proxy.Invoke(nameof(BindAttributeCore), node, attributeType, diagnostics);
    }
}
