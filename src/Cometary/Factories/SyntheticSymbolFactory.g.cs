using System;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Semantics;
using Microsoft.CodeAnalysis.Text;

namespace Cometary
{
    partial class SyntheticSymbolFactory
    {
        public IOperation Conditional(IOperation condition, IOperation consequence, IOperation alternative, ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(Conditional), condition, consequence, alternative, type);
        public IOperation ComplexConditionalReceiver(IOperation valueTypeReceiver, IOperation referenceTypeReceiver) => (IOperation)proxy.Invoke(nameof(ComplexConditionalReceiver), valueTypeReceiver, referenceTypeReceiver);
        public IOperation Coalesce(IOperation left, IOperation right) => (IOperation)proxy.Invoke(nameof(Coalesce), left, right);
        public IOperation If(IOperation condition, IOperation thenClause, IOperation elseClauseOpt = null) => (IOperation)proxy.Invoke(nameof(If), condition, thenClause, elseClauseOpt);
        public IOperation ConditionalGoto(IOperation condition, ILabelSymbol label, Boolean jumpIfTrue) => (IOperation)proxy.Invoke(nameof(ConditionalGoto), condition, label, jumpIfTrue);
        public IOperation If(IOperation condition, ImmutableArray<ISymbol> locals, IOperation thenClause, IOperation elseClauseOpt = null) => (IOperation)proxy.Invoke(nameof(If), condition, locals, thenClause, elseClauseOpt);
        public IThrowStatement Throw(IOperation e = null) => (IThrowStatement)proxy.Invoke(nameof(Throw), e);
        public ILocalReferenceExpression Local(ILocalSymbol local) => (ILocalReferenceExpression)proxy.Invoke(nameof(Local), local);
        public IOperation MakeSequence(ILocalSymbol temp, IOperation[][] parts) => (IOperation)proxy.Invoke(nameof(MakeSequence), temp, parts);
        public IOperation MakeSequence(IOperation[][] parts) => (IOperation)proxy.Invoke(nameof(MakeSequence), parts);
        public IOperation MakeSequence(ImmutableArray<ISymbol> locals, IOperation[][] parts) => (IOperation)proxy.Invoke(nameof(MakeSequence), locals, parts);
        public IOperation Sequence(IOperation[][] sideEffects, IOperation result, ITypeSymbol type = null) => (IOperation)proxy.Invoke(nameof(Sequence), sideEffects, result, type);
        public IOperation Sequence(ImmutableArray<ISymbol> locals, ImmutableArray<IOperation> sideEffects, IOperation result) => (IOperation)proxy.Invoke(nameof(Sequence), locals, sideEffects, result);
        public IOperation Switch(IOperation ex, IOperation[][] sections) => (IOperation)proxy.Invoke(nameof(Switch), ex, sections);
        public IOperation Switch(IOperation ex, IEnumerable<IOperation> sections) => (IOperation)proxy.Invoke(nameof(Switch), ex, sections);
        public IOperation SwitchSection(Int32 value, IOperation[][] statements) => (IOperation)proxy.Invoke(nameof(SwitchSection), value, statements);
        public IOperation SwitchSection(List<Int32> values, IOperation[][] statements) => (IOperation)proxy.Invoke(nameof(SwitchSection), values, statements);
        public IBranchStatement Goto(ILabelSymbol label) => (IBranchStatement)proxy.Invoke(nameof(Goto), label);
        public ILabelStatement Label(ILabelSymbol label) => (ILabelStatement)proxy.Invoke(nameof(Label), label);
        public ILiteralExpression Literal(Boolean value) => (ILiteralExpression)proxy.Invoke(nameof(Literal), value);
        public ILiteralExpression Literal(String value) => (ILiteralExpression)proxy.Invoke(nameof(Literal), value);
        public ILiteralExpression StringLiteral(Object stringConst) => (ILiteralExpression)proxy.Invoke(nameof(StringLiteral), stringConst);
        public ILiteralExpression StringLiteral(String stringValue) => (ILiteralExpression)proxy.Invoke(nameof(StringLiteral), stringValue);
        public IOperation ArrayLength(IOperation array) => (IOperation)proxy.Invoke(nameof(ArrayLength), array);
        public IArrayElementReferenceExpression ArrayAccessFirstElement(IOperation array) => (IArrayElementReferenceExpression)proxy.Invoke(nameof(ArrayAccessFirstElement), array);
        public IArrayElementReferenceExpression ArrayAccess(IOperation array, IOperation[][] indices) => (IArrayElementReferenceExpression)proxy.Invoke(nameof(ArrayAccess), array, indices);
        public IArrayElementReferenceExpression ArrayAccess(IOperation array, ImmutableArray<IOperation> indices) => (IArrayElementReferenceExpression)proxy.Invoke(nameof(ArrayAccess), array, indices);
        public IOperation BaseInitialization() => (IOperation)proxy.Invoke(nameof(BaseInitialization));
        public IOperation SequencePoint(SyntaxNode syntax, IOperation statement) => (IOperation)proxy.Invoke(nameof(SequencePoint), syntax, statement);
        public IOperation SequencePointWithSpan(CSharpSyntaxNode syntax, TextSpan span, IOperation statement) => (IOperation)proxy.Invoke(nameof(SequencePointWithSpan), syntax, span, statement);
        public IOperation HiddenSequencePoint() => (IOperation)proxy.Invoke(nameof(HiddenSequencePoint));
        public IOperation ThrowNull() => (IOperation)proxy.Invoke(nameof(ThrowNull));
        public IOperation ThrowExpression(IOperation thrown, ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(ThrowExpression), thrown, type);
        public IOperation Null(ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(Null), type);
        public IOperation Type(ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(Type), type);
        public IOperation Typeof(Int32 type) => (IOperation)proxy.Invoke(nameof(Typeof), type);
        public IOperation Typeof(ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(Typeof), type);
        public ImmutableArray<IOperation> TypeOfs(ImmutableArray<INamespaceOrTypeSymbol> typeArguments) => (ImmutableArray<IOperation>)proxy.Invoke(nameof(TypeOfs), typeArguments);
        public IOperation TypeofDynamicOperationContextType() => (IOperation)proxy.Invoke(nameof(TypeofDynamicOperationContextType));
        public IOperation Sizeof(ITypeSymbol type) => (IOperation)proxy.Invoke(nameof(Sizeof), type);
        public IOperation MethodDefIndex(IMethodSymbol method) => (IOperation)proxy.Invoke(nameof(MethodDefIndex), method);
        public IOperation ModuleVersionId() => (IOperation)proxy.Invoke(nameof(ModuleVersionId));
        public IOperation ModuleVersionIdString() => (IOperation)proxy.Invoke(nameof(ModuleVersionIdString));
        public IOperation InstrumentationPayloadRoot(Int32 analysisKind, ITypeSymbol payloadType) => (IOperation)proxy.Invoke(nameof(InstrumentationPayloadRoot), analysisKind, payloadType);
        public IOperation MaximumMethodDefIndex() => (IOperation)proxy.Invoke(nameof(MaximumMethodDefIndex));
        public IOperation SourceDocumentIndex(Object document) => (IOperation)proxy.Invoke(nameof(SourceDocumentIndex), document);
        public IOperation MethodInfo(IMethodSymbol method) => (IOperation)proxy.Invoke(nameof(MethodInfo), method);
        public IOperation FieldInfo(IFieldSymbol field) => (IOperation)proxy.Invoke(nameof(FieldInfo), field);
        public IOperation Convert(ITypeSymbol type, IOperation arg) => (IOperation)proxy.Invoke(nameof(Convert), type, arg);
        public IOperation Convert(ITypeSymbol type, IOperation arg, Conversion conversion, Boolean isChecked = false) => (IOperation)proxy.Invoke(nameof(Convert), type, arg, conversion, isChecked);
        public IOperation ArrayOrEmpty(ITypeSymbol elementType, IOperation[][] elements) => (IOperation)proxy.Invoke(nameof(ArrayOrEmpty), elementType, elements);
        public IOperation ArrayOrEmpty(ITypeSymbol elementType, ImmutableArray<IOperation> elements) => (IOperation)proxy.Invoke(nameof(ArrayOrEmpty), elementType, elements);
        public IOperation Array(ITypeSymbol elementType, ImmutableArray<IOperation> elements) => (IOperation)proxy.Invoke(nameof(Array), elementType, elements);
        public IOperation Array(ITypeSymbol elementType, IOperation length) => (IOperation)proxy.Invoke(nameof(Array), elementType, length);
        public ILocalReferenceExpression StoreToTemp(IOperation argument, Object store, Byte refKind = 0, Int32 kind = -2, SyntaxNode syntaxOpt = null) => (ILocalReferenceExpression)proxy.Invoke(nameof(StoreToTemp), argument, store, refKind, kind, syntaxOpt);
        public void AddNestedType(INamedTypeSymbol nestedType) => proxy.Invoke(nameof(AddNestedType), nestedType);
        public void OpenNestedType(INamedTypeSymbol nestedType) => proxy.Invoke(nameof(OpenNestedType), nestedType);
        public IOperation HoistedField(IFieldSymbol field) => (IOperation)proxy.Invoke(nameof(HoistedField), field);
        public IFieldSymbol StateMachineField(ITypeSymbol type, String name, Boolean isPublic = false, Boolean isThis = false) => (IFieldSymbol)proxy.Invoke(nameof(StateMachineField), type, name, isPublic, isThis);
        public IFieldSymbol StateMachineField(ITypeSymbol type, String name, Int32 synthesizedKind, Int32 slotIndex) => (IFieldSymbol)proxy.Invoke(nameof(StateMachineField), type, name, synthesizedKind, slotIndex);
        public IFieldSymbol StateMachineField(ITypeSymbol type, String name, ValueType slotDebugInfo, Int32 slotIndex) => (IFieldSymbol)proxy.Invoke(nameof(StateMachineField), type, name, slotDebugInfo, slotIndex);
        public void AddField(INamedTypeSymbol containingType, IFieldSymbol field) => proxy.Invoke(nameof(AddField), containingType, field);
        public ILabelSymbol GenerateLabel(String prefix) => (ILabelSymbol)proxy.Invoke(nameof(GenerateLabel), prefix);
        public IInstanceReferenceExpression This() => (IInstanceReferenceExpression)proxy.Invoke(nameof(This));
        public IOperation This(ILocalSymbol thisTempOpt) => (IOperation)proxy.Invoke(nameof(This), thisTempOpt);
        public IInstanceReferenceExpression Base() => (IInstanceReferenceExpression)proxy.Invoke(nameof(Base));
        public IInvalidExpression BadExpression(ITypeSymbol type) => (IInvalidExpression)proxy.Invoke(nameof(BadExpression), type);
        public IParameterReferenceExpression Parameter(IParameterSymbol p) => (IParameterReferenceExpression)proxy.Invoke(nameof(Parameter), p);
        public IFieldReferenceExpression Field(IOperation receiver, IFieldSymbol f) => (IFieldReferenceExpression)proxy.Invoke(nameof(Field), receiver, f);
        public IOperation Property(Int32 member) => (IOperation)proxy.Invoke(nameof(Property), member);
        public IOperation Property(IOperation receiver, Int32 member) => (IOperation)proxy.Invoke(nameof(Property), receiver, member);
        public IOperation Property(IOperation receiver, IPropertySymbol property) => (IOperation)proxy.Invoke(nameof(Property), receiver, property);
        public INamedTypeSymbol SpecialType(SByte st) => (INamedTypeSymbol)proxy.Invoke(nameof(SpecialType), st);
        public IArrayTypeSymbol WellKnownArrayType(Int32 elementType) => (IArrayTypeSymbol)proxy.Invoke(nameof(WellKnownArrayType), elementType);
        public INamedTypeSymbol WellKnownType(Int32 wt) => (INamedTypeSymbol)proxy.Invoke(nameof(WellKnownType), wt);
        public ISymbol WellKnownMember(Int32 wm, Boolean isOptional = false) => (ISymbol)proxy.Invoke(nameof(WellKnownMember), wm, isOptional);
        public IMethodSymbol WellKnownMethod(Int32 wm, Boolean isOptional = false) => (IMethodSymbol)proxy.Invoke(nameof(WellKnownMethod), wm, isOptional);
        public ISymbol SpecialMember(Int32 sm) => (ISymbol)proxy.Invoke(nameof(SpecialMember), sm);
        public IMethodSymbol SpecialMethod(Int32 sm) => (IMethodSymbol)proxy.Invoke(nameof(SpecialMethod), sm);
        public IPropertySymbol SpecialProperty(Int32 sm) => (IPropertySymbol)proxy.Invoke(nameof(SpecialProperty), sm);
        public IExpressionStatement Assignment(IOperation left, IOperation right, Byte refKind = 0) => (IExpressionStatement)proxy.Invoke(nameof(Assignment), left, right, refKind);
        public IExpressionStatement ExpressionStatement(IOperation expr) => (IExpressionStatement)proxy.Invoke(nameof(ExpressionStatement), expr);
        public IAssignmentExpression AssignmentExpression(IOperation left, IOperation right, Byte refKind = 0) => (IAssignmentExpression)proxy.Invoke(nameof(AssignmentExpression), left, right, refKind);
        public IBlockStatement Block() => (IBlockStatement)proxy.Invoke(nameof(Block));
        public IBlockStatement Block(ImmutableArray<IOperation> statements) => (IBlockStatement)proxy.Invoke(nameof(Block), statements);
        public IBlockStatement Block(IOperation[][] statements) => (IBlockStatement)proxy.Invoke(nameof(Block), statements);
        public IBlockStatement Block(ImmutableArray<ISymbol> locals, IOperation[][] statements) => (IBlockStatement)proxy.Invoke(nameof(Block), locals, statements);
        public IBlockStatement Block(ImmutableArray<ISymbol> locals, ImmutableArray<IOperation> statements) => (IBlockStatement)proxy.Invoke(nameof(Block), locals, statements);
        public IBlockStatement Block(ImmutableArray<ISymbol> locals, ImmutableArray<ISymbol> localFunctions, IOperation[][] statements) => (IBlockStatement)proxy.Invoke(nameof(Block), locals, localFunctions, statements);
        public IBlockStatement Block(ImmutableArray<ISymbol> locals, ImmutableArray<ISymbol> localFunctions, ImmutableArray<IOperation> statements) => (IBlockStatement)proxy.Invoke(nameof(Block), locals, localFunctions, statements);
        public IOperation StatementList() => (IOperation)proxy.Invoke(nameof(StatementList));
        public IOperation StatementList(ImmutableArray<IOperation> statements) => (IOperation)proxy.Invoke(nameof(StatementList), statements);
        public IOperation StatementList(IOperation first, IOperation second) => (IOperation)proxy.Invoke(nameof(StatementList), first, second);
        public IReturnStatement Return(IOperation expression = null) => (IReturnStatement)proxy.Invoke(nameof(Return), expression);
        public void CloseMethod(IOperation body) => proxy.Invoke(nameof(CloseMethod), body);
        public ILocalSymbol SynthesizedLocal(ITypeSymbol type, SyntaxNode syntax = null, Boolean isPinned = false, Byte refKind = 0, Int32 kind = -2) => (ILocalSymbol)proxy.Invoke(nameof(SynthesizedLocal), type, syntax, isPinned, refKind, kind);
        public IParameterSymbol SynthesizedParameter(ITypeSymbol type, String name, IMethodSymbol container = null, Int32 ordinal = 0) => (IParameterSymbol)proxy.Invoke(nameof(SynthesizedParameter), type, name, container, ordinal);
        public IBinaryOperatorExpression Binary(Int32 kind, ITypeSymbol type, IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(Binary), kind, type, left, right);
        public IConversionExpression As(IOperation operand, ITypeSymbol type) => (IConversionExpression)proxy.Invoke(nameof(As), operand, type);
        public IIsTypeExpression Is(IOperation operand, ITypeSymbol type) => (IIsTypeExpression)proxy.Invoke(nameof(Is), operand, type);
        public IBinaryOperatorExpression LogicalAnd(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(LogicalAnd), left, right);
        public IBinaryOperatorExpression LogicalOr(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(LogicalOr), left, right);
        public IBinaryOperatorExpression IntEqual(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(IntEqual), left, right);
        public IBinaryOperatorExpression ObjectEqual(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(ObjectEqual), left, right);
        public IBinaryOperatorExpression ObjectNotEqual(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(ObjectNotEqual), left, right);
        public IBinaryOperatorExpression IntNotEqual(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(IntNotEqual), left, right);
        public IBinaryOperatorExpression IntLessThan(IOperation left, IOperation right) => (IBinaryOperatorExpression)proxy.Invoke(nameof(IntLessThan), left, right);
        public ILiteralExpression Literal(Int32 value) => (ILiteralExpression)proxy.Invoke(nameof(Literal), value);
        public ILiteralExpression Literal(UInt32 value) => (ILiteralExpression)proxy.Invoke(nameof(Literal), value);
        public IObjectCreationExpression New(INamedTypeSymbol type, IOperation[][] args) => (IObjectCreationExpression)proxy.Invoke(nameof(New), type, args);
        public IObjectCreationExpression New(IMethodSymbol ctor, IOperation[][] args) => (IObjectCreationExpression)proxy.Invoke(nameof(New), ctor, args);
        public IOperation InstanceCall(IOperation receiver, String name, IOperation arg) => (IOperation)proxy.Invoke(nameof(InstanceCall), receiver, name, arg);
        public IOperation InstanceCall(IOperation receiver, String name) => (IOperation)proxy.Invoke(nameof(InstanceCall), receiver, name);
        public IOperation StaticCall(ITypeSymbol receiver, String name, IOperation[][] args) => (IOperation)proxy.Invoke(nameof(StaticCall), receiver, name, args);
        public IOperation StaticCall(ITypeSymbol receiver, String name, ImmutableArray<IOperation> args, Boolean allowUnexpandedForm) => (IOperation)proxy.Invoke(nameof(StaticCall), receiver, name, args, allowUnexpandedForm);
        public IOperation StaticCall(UInt32 flags, ITypeSymbol receiver, String name, ImmutableArray<INamespaceOrTypeSymbol> typeArgs, IOperation[][] args) => (IOperation)proxy.Invoke(nameof(StaticCall), flags, receiver, name, typeArgs, args);
        public IOperation StaticCall(ITypeSymbol receiver, IMethodSymbol method, IOperation[][] args) => (IOperation)proxy.Invoke(nameof(StaticCall), receiver, method, args);
        public IOperation StaticCall(Int32 method, IOperation[][] args) => (IOperation)proxy.Invoke(nameof(StaticCall), method, args);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method, IOperation arg0) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method, arg0);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method, IOperation arg0, IOperation arg1) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method, arg0, arg1);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method, IOperation[][] args) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method, args);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method, ImmutableArray<IOperation> args) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method, args);
        public IInvocationExpression Call(IOperation receiver, IMethodSymbol method, ImmutableArray<Byte> refKinds, ImmutableArray<IOperation> args) => (IInvocationExpression)proxy.Invoke(nameof(Call), receiver, method, refKinds, args);
    }
}
