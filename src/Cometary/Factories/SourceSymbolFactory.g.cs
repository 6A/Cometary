using System;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Semantics;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cometary
{
    partial class SourceSymbolFactory
    {
        public static Object CreateAnonymousTypeManager(CSharpCompilation compilation) => (Object)Invoke(0, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager"), nameof(CreateAnonymousTypeManager), compilation);
        public static IMethodSymbol CreateSynthesizedStringSwitchHashMethod(IModuleSymbol containingModule, Object privateImplType, ITypeSymbol returnType, ITypeSymbol paramType) => (IMethodSymbol)Invoke(1, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod"), nameof(CreateSynthesizedStringSwitchHashMethod), containingModule, privateImplType, returnType, paramType);
        public static IMethodSymbol CreateSynthesizedExplicitImplementationForwardingMethod(IMethodSymbol interfaceMethod, IMethodSymbol implementingMethod, INamedTypeSymbol implementingType) => (IMethodSymbol)Invoke(2, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod"), nameof(CreateSynthesizedExplicitImplementationForwardingMethod), interfaceMethod, implementingMethod, implementingType);
        public static IMethodSymbol CreateSynthesizedSealedPropertyAccessor(IPropertySymbol property, IMethodSymbol overriddenAccessor) => (IMethodSymbol)Invoke(3, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor"), nameof(CreateSynthesizedSealedPropertyAccessor), property, overriddenAccessor);
        public static ISourceAssemblySymbol CreateSourceAssemblySymbol(CSharpCompilation compilation, String assemblySimpleName, String moduleName, ImmutableArray<Object> netModules) => (ISourceAssemblySymbol)Invoke(4, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol"), nameof(CreateSourceAssemblySymbol), compilation, assemblySimpleName, moduleName, netModules);
        public static IDynamicTypeSymbol CreateDynamicTypeSymbol() => (IDynamicTypeSymbol)Invoke(5, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol"), nameof(CreateDynamicTypeSymbol));
        public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType) => (IPointerTypeSymbol)Invoke(6, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol"), nameof(CreatePointerTypeSymbol), pointedAtType);
        public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType, ImmutableArray<CustomModifier> customModifiers) => (IPointerTypeSymbol)Invoke(7, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol"), nameof(CreatePointerTypeSymbol), pointedAtType, customModifiers);
        public static IMethodSymbol CreateSynthesizedPrivateImplementationDetailsStaticConstructor(IModuleSymbol containingModule, Object privateImplementationType, INamedTypeSymbol voidType) => (IMethodSymbol)Invoke(8, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedPrivateImplementationDetailsStaticConstructor"), nameof(CreateSynthesizedPrivateImplementationDetailsStaticConstructor), containingModule, privateImplementationType, voidType);
        public static IAliasSymbol CreateAliasSymbol(Object binder, INamespaceOrTypeSymbol target, SyntaxToken aliasName, ImmutableArray<Location> locations) => (IAliasSymbol)Invoke(9, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol"), nameof(CreateAliasSymbol), binder, target, aliasName, locations);
        public static IAliasSymbol CreateAliasSymbol(Object binder, SyntaxToken aliasName) => (IAliasSymbol)Invoke(10, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol"), nameof(CreateAliasSymbol), binder, aliasName);
        public static IAliasSymbol CreateAliasSymbol(Object binder, UsingDirectiveSyntax syntax) => (IAliasSymbol)Invoke(11, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol"), nameof(CreateAliasSymbol), binder, syntax);
        public static IAliasSymbol CreateAliasSymbol(Object binder, ExternAliasDirectiveSyntax syntax) => (IAliasSymbol)Invoke(12, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol"), nameof(CreateAliasSymbol), binder, syntax);
        public static ValueType CreateAnonymousTypeDescriptor(ImmutableArray<ValueType> fields, Location location) => (ValueType)Invoke(13, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor"), nameof(CreateAnonymousTypeDescriptor), fields, location);
        public static ValueType CreateAnonymousTypeField(String name, Location location, ITypeSymbol type) => (ValueType)Invoke(14, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField"), nameof(CreateAnonymousTypeField), name, location, type);
        public static INamedTypeSymbol CreateSynthesizedEmbeddedAttributeSymbol(ValueType description, CSharpCompilation compilation, Object diagnostics) => (INamedTypeSymbol)Invoke(15, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEmbeddedAttributeSymbol"), nameof(CreateSynthesizedEmbeddedAttributeSymbol), description, compilation, diagnostics);
        public static IEventSymbol CreateTupleEventSymbol(INamedTypeSymbol container, IEventSymbol underlyingEvent) => (IEventSymbol)Invoke(16, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleEventSymbol"), nameof(CreateTupleEventSymbol), container, underlyingEvent);
        public static IFieldSymbol CreateTupleVirtualElementFieldSymbol(INamedTypeSymbol container, IFieldSymbol underlyingField, String name, Int32 tupleElementIndex, Location location, Boolean cannotUse, Boolean isImplicitlyDeclared, IFieldSymbol correspondingDefaultFieldOpt) => (IFieldSymbol)Invoke(17, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleVirtualElementFieldSymbol"), nameof(CreateTupleVirtualElementFieldSymbol), container, underlyingField, name, tupleElementIndex, location, cannotUse, isImplicitlyDeclared, correspondingDefaultFieldOpt);
        public static IMethodSymbol CreateTupleMethodSymbol(INamedTypeSymbol container, IMethodSymbol underlyingMethod) => (IMethodSymbol)Invoke(18, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleMethodSymbol"), nameof(CreateTupleMethodSymbol), container, underlyingMethod);
        public static IParameterSymbol CreateTupleParameterSymbol(ISymbol container, IParameterSymbol underlyingParameter) => (IParameterSymbol)Invoke(19, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleParameterSymbol"), nameof(CreateTupleParameterSymbol), container, underlyingParameter);
        public static IFieldSymbol CreateTupleErrorFieldSymbol(INamedTypeSymbol container, String name, Int32 tupleElementIndex, Location location, ITypeSymbol type, Object useSiteDiagnosticInfo, Boolean isImplicitlyDeclared, IFieldSymbol correspondingDefaultFieldOpt) => (IFieldSymbol)Invoke(20, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleErrorFieldSymbol"), nameof(CreateTupleErrorFieldSymbol), container, name, tupleElementIndex, location, type, useSiteDiagnosticInfo, isImplicitlyDeclared, correspondingDefaultFieldOpt);
        public static IPropertySymbol CreateTuplePropertySymbol(INamedTypeSymbol container, IPropertySymbol underlyingProperty) => (IPropertySymbol)Invoke(21, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TuplePropertySymbol"), nameof(CreateTuplePropertySymbol), container, underlyingProperty);
        public static INamedTypeSymbol Create(INamedTypeSymbol tupleCompatibleType, ImmutableArray<String> elementNames = default(ImmutableArray<String>), ImmutableArray<Boolean> errorPositions = default(ImmutableArray<Boolean>), Location locationOpt = null, ImmutableArray<Location> elementLocations = default(ImmutableArray<Location>)) => (INamedTypeSymbol)Invoke(22, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol"), tupleCompatibleType, elementNames, errorPositions, locationOpt, elementLocations);
        public static INamedTypeSymbol Create(ImmutableArray<Location> locations, INamedTypeSymbol tupleCompatibleType, ImmutableArray<Location> elementLocations, ImmutableArray<String> elementNames, ImmutableArray<Boolean> errorPositions) => (INamedTypeSymbol)Invoke(23, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol"), locations, tupleCompatibleType, elementLocations, elementNames, errorPositions);
        public static INamedTypeSymbol CreateTupleTypeSymbol(Location locationOpt, INamedTypeSymbol underlyingType, ImmutableArray<Location> elementLocations, ImmutableArray<String> elementNames, ImmutableArray<INamespaceOrTypeSymbol> elementTypes, ImmutableArray<Boolean> errorPositions) => (INamedTypeSymbol)Invoke(24, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol"), nameof(CreateTupleTypeSymbol), locationOpt, underlyingType, elementLocations, elementNames, elementTypes, errorPositions);
        public static INamedTypeSymbol CreateTupleTypeSymbol(ImmutableArray<Location> locations, INamedTypeSymbol underlyingType, ImmutableArray<Location> elementLocations, ImmutableArray<String> elementNames, ImmutableArray<INamespaceOrTypeSymbol> elementTypes, ImmutableArray<Boolean> errorPositions) => (INamedTypeSymbol)Invoke(25, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TupleTypeSymbol"), nameof(CreateTupleTypeSymbol), locations, underlyingType, elementLocations, elementNames, elementTypes, errorPositions);
        public static Object CreateParameterEarlyWellKnownAttributeData() => (Object)Invoke(26, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ParameterEarlyWellKnownAttributeData"), nameof(CreateParameterEarlyWellKnownAttributeData));
        public static Object CreatePropertyEarlyWellKnownAttributeData() => (Object)Invoke(27, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.PropertyEarlyWellKnownAttributeData"), nameof(CreatePropertyEarlyWellKnownAttributeData));
        public static Object CreateTypeWellKnownAttributeData() => (Object)Invoke(28, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeWellKnownAttributeData"), nameof(CreateTypeWellKnownAttributeData));
        public static Object CreateEvaluatedConstant(Object value, ImmutableArray<Diagnostic> diagnostics) => (Object)Invoke(29, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.EvaluatedConstant"), nameof(CreateEvaluatedConstant), value, diagnostics);
        public static ValueType CreateTypeParameterDiagnosticInfo(ITypeParameterSymbol typeParameter, Object diagnosticInfo) => (ValueType)Invoke(30, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo"), nameof(CreateTypeParameterDiagnosticInfo), typeParameter, diagnosticInfo);
        public static IMethodSymbol CreateConstructedMethodSymbol(IMethodSymbol constructedFrom, ImmutableArray<INamespaceOrTypeSymbol> typeArguments) => (IMethodSymbol)Invoke(31, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedMethodSymbol"), nameof(CreateConstructedMethodSymbol), constructedFrom, typeArguments);
        public static INamedTypeSymbol CreateSubstitutedNestedTypeSymbol(INamedTypeSymbol newContainer, INamedTypeSymbol originalDefinition) => (INamedTypeSymbol)Invoke(32, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedTypeSymbol"), nameof(CreateSubstitutedNestedTypeSymbol), newContainer, originalDefinition);
        public static INamedTypeSymbol CreateConstructedNamedTypeSymbol(INamedTypeSymbol constructedFrom, ImmutableArray<ValueType> typeArguments, Boolean unbound = false) => (INamedTypeSymbol)Invoke(33, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedNamedTypeSymbol"), nameof(CreateConstructedNamedTypeSymbol), constructedFrom, typeArguments, unbound);
        public static Object CreateConversionSignatureComparer() => (Object)Invoke(34, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConversionSignatureComparer"), nameof(CreateConversionSignatureComparer));
        public static Object CreateDynamicTypeEraser(ITypeSymbol objectType) => (Object)Invoke(35, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeEraser"), nameof(CreateDynamicTypeEraser), objectType);
        public static IMethodSymbol CreateErrorMethodSymbol(ITypeSymbol containingType, ITypeSymbol returnType, String name) => (IMethodSymbol)Invoke(36, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ErrorMethodSymbol"), nameof(CreateErrorMethodSymbol), containingType, returnType, name);
        public static IPropertySymbol CreateErrorPropertySymbol(ISymbol containingSymbol, ITypeSymbol type, String name, Boolean isIndexer, Boolean isIndexedProperty) => (IPropertySymbol)Invoke(37, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ErrorPropertySymbol"), nameof(CreateErrorPropertySymbol), containingSymbol, type, name, isIndexer, isIndexedProperty);
        public static IErrorTypeSymbol CreateConstructedErrorTypeSymbol(IErrorTypeSymbol constructedFrom, ImmutableArray<ValueType> typeArguments) => (IErrorTypeSymbol)Invoke(38, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedErrorTypeSymbol"), nameof(CreateConstructedErrorTypeSymbol), constructedFrom, typeArguments);
        public static IErrorTypeSymbol CreateSubstitutedNestedErrorTypeSymbol(INamedTypeSymbol containingSymbol, IErrorTypeSymbol originalDefinition) => (IErrorTypeSymbol)Invoke(39, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedErrorTypeSymbol"), nameof(CreateSubstitutedNestedErrorTypeSymbol), containingSymbol, originalDefinition);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(CSharpCompilation compilation, String name, Int32 arity, Object errorInfo, Boolean unreported = false, Boolean variableUsedBeforeDeclaration = false) => (IErrorTypeSymbol)Invoke(40, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), compilation, name, arity, errorInfo, unreported, variableUsedBeforeDeclaration);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(INamespaceOrTypeSymbol containingSymbol, String name, Int32 arity, Object errorInfo, Boolean unreported = false, Boolean variableUsedBeforeDeclaration = false) => (IErrorTypeSymbol)Invoke(41, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), containingSymbol, name, arity, errorInfo, unreported, variableUsedBeforeDeclaration);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(INamespaceOrTypeSymbol containingSymbol, String name, Int32 arity, Object errorInfo, Boolean unreported, Boolean variableUsedBeforeDeclaration, ImmutableArray<ISymbol> candidateSymbols, Byte resultKind) => (IErrorTypeSymbol)Invoke(42, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), containingSymbol, name, arity, errorInfo, unreported, variableUsedBeforeDeclaration, candidateSymbols, resultKind);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(INamespaceOrTypeSymbol guessSymbol, Byte resultKind, Object errorInfo, Boolean unreported = false) => (IErrorTypeSymbol)Invoke(43, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), guessSymbol, resultKind, errorInfo, unreported);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(INamespaceOrTypeSymbol containingSymbol, ISymbol guessSymbol, Byte resultKind, Object errorInfo, Boolean unreported = false) => (IErrorTypeSymbol)Invoke(44, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), containingSymbol, guessSymbol, resultKind, errorInfo, unreported);
        public static IErrorTypeSymbol CreateExtendedErrorTypeSymbol(INamespaceOrTypeSymbol containingSymbol, ImmutableArray<ISymbol> candidateSymbols, Byte resultKind, Object errorInfo, Int32 arity, Boolean unreported = false) => (IErrorTypeSymbol)Invoke(45, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol"), nameof(CreateExtendedErrorTypeSymbol), containingSymbol, candidateSymbols, resultKind, errorInfo, arity, unreported);
        public static ValueType CreateFieldOrPropertyInitializer(IFieldSymbol fieldOpt, SyntaxNode syntax, Int32 precedingInitializersLength) => (ValueType)Invoke(46, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer"), nameof(CreateFieldOrPropertyInitializer), fieldOpt, syntax, precedingInitializersLength);
        public static ValueType CreateLexicalSortKey(Int32 treeOrdinal, Int32 position) => (ValueType)Invoke(47, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), treeOrdinal, position);
        public static ValueType CreateLexicalSortKey(SyntaxTree tree, Int32 position, CSharpCompilation compilation) => (ValueType)Invoke(48, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), tree, position, compilation);
        public static ValueType CreateLexicalSortKey(SyntaxReference syntaxRef, CSharpCompilation compilation) => (ValueType)Invoke(49, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), syntaxRef, compilation);
        public static ValueType CreateLexicalSortKey(Location location, CSharpCompilation compilation) => (ValueType)Invoke(50, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), location, compilation);
        public static ValueType CreateLexicalSortKey(CSharpSyntaxNode node, CSharpCompilation compilation) => (ValueType)Invoke(51, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), node, compilation);
        public static ValueType CreateLexicalSortKey(SyntaxToken token, CSharpCompilation compilation) => (ValueType)Invoke(52, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey"), nameof(CreateLexicalSortKey), token, compilation);
        public static INamespaceSymbol CreateMergedNamespaceSymbol(ValueType extent, INamespaceSymbol containingNamespace, ImmutableArray<INamespaceOrTypeSymbol> namespacesToMerge, String nameOpt) => (INamespaceSymbol)Invoke(53, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol"), nameof(CreateMergedNamespaceSymbol), extent, containingNamespace, namespacesToMerge, nameOpt);
        public static IAssemblySymbol CreateMissingCorLibrarySymbol() => (IAssemblySymbol)Invoke(54, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol"), nameof(CreateMissingCorLibrarySymbol));
        public static Object CreateMutableTypeMap() => (Object)Invoke(55, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap"), nameof(CreateMutableTypeMap));
        public static ValueType CreateNamespaceExtent(IModuleSymbol module) => (ValueType)Invoke(56, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent"), nameof(CreateNamespaceExtent), module);
        public static ValueType CreateNamespaceExtent(IAssemblySymbol assembly) => (ValueType)Invoke(57, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent"), nameof(CreateNamespaceExtent), assembly);
        public static ValueType CreateNamespaceExtent(CSharpCompilation compilation) => (ValueType)Invoke(58, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent"), nameof(CreateNamespaceExtent), compilation);
        public static Object Create(ImmutableArray<ISymbol> overriddenMembers, ImmutableArray<ISymbol> hiddenMembers, ImmutableArray<ISymbol> runtimeOverriddenMembers) => (Object)Invoke(59, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult"), overriddenMembers, hiddenMembers, runtimeOverriddenMembers);
        public static Object CreateOverriddenOrHiddenMembersResult(ImmutableArray<ISymbol> overriddenMembers, ImmutableArray<ISymbol> hiddenMembers, ImmutableArray<ISymbol> runtimeOverriddenMembers) => (Object)Invoke(60, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult"), nameof(CreateOverriddenOrHiddenMembersResult), overriddenMembers, hiddenMembers, runtimeOverriddenMembers);
        public static IMethodSymbol Create(IMethodSymbol method, ITypeSymbol receiverType, Compilation compilation) => (IMethodSymbol)Invoke(61, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol"), method, receiverType, compilation);
        public static IMethodSymbol Create(IMethodSymbol method) => (IMethodSymbol)Invoke(62, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol"), method);
        public static IMethodSymbol CreateReducedExtensionMethodSymbol(IMethodSymbol reducedFrom) => (IMethodSymbol)Invoke(63, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol"), nameof(CreateReducedExtensionMethodSymbol), reducedFrom);
        public static IMethodSymbol CreateSignatureOnlyMethodSymbol(String name, ITypeSymbol containingType, Int32 methodKind, Int32 callingConvention, ImmutableArray<ITypeSymbol> typeParameters, ImmutableArray<ISymbol> parameters, Byte refKind, ITypeSymbol returnType, ImmutableArray<CustomModifier> returnTypeCustomModifiers, ImmutableArray<CustomModifier> refCustomModifiers, ImmutableArray<ISymbol> explicitInterfaceImplementations) => (IMethodSymbol)Invoke(64, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyMethodSymbol"), nameof(CreateSignatureOnlyMethodSymbol), name, containingType, methodKind, callingConvention, typeParameters, parameters, refKind, returnType, returnTypeCustomModifiers, refCustomModifiers, explicitInterfaceImplementations);
        public static IParameterSymbol CreateSignatureOnlyParameterSymbol(ITypeSymbol type, ImmutableArray<CustomModifier> customModifiers, ImmutableArray<CustomModifier> refCustomModifiers, Boolean isParams, Byte refKind) => (IParameterSymbol)Invoke(65, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyParameterSymbol"), nameof(CreateSignatureOnlyParameterSymbol), type, customModifiers, refCustomModifiers, isParams, refKind);
        public static IPropertySymbol CreateSignatureOnlyPropertySymbol(String name, ITypeSymbol containingType, ImmutableArray<ISymbol> parameters, Byte refKind, ITypeSymbol type, ImmutableArray<CustomModifier> typeCustomModifiers, ImmutableArray<CustomModifier> refCustomModifiers, Boolean isStatic, ImmutableArray<ISymbol> explicitInterfaceImplementations) => (IPropertySymbol)Invoke(66, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyPropertySymbol"), nameof(CreateSignatureOnlyPropertySymbol), name, containingType, parameters, refKind, type, typeCustomModifiers, refCustomModifiers, isStatic, explicitInterfaceImplementations);
        public static ITypeParameterSymbol CreateCrefTypeParameterSymbol(String name, Int32 ordinal, IdentifierNameSyntax declaringSyntax) => (ITypeParameterSymbol)Invoke(67, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol"), nameof(CreateCrefTypeParameterSymbol), name, ordinal, declaringSyntax);
        public static INamedTypeSymbol CreateImplicitNamedTypeSymbol(INamespaceOrTypeSymbol containingSymbol, Object declaration, Object diagnostics) => (INamedTypeSymbol)Invoke(68, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ImplicitNamedTypeSymbol"), nameof(CreateImplicitNamedTypeSymbol), containingSymbol, declaration, diagnostics);
        public static ITypeParameterSymbol CreateIndexedTypeParameterSymbol(Int32 index) => (ITypeParameterSymbol)Invoke(69, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol"), nameof(CreateIndexedTypeParameterSymbol), index);
        public static IMethodSymbol CreateLambdaSymbol(CSharpCompilation compilation, ISymbol containingSymbol, IUnboundLambdaExpression unboundLambda, ImmutableArray<INamespaceOrTypeSymbol> parameterTypes, ImmutableArray<Byte> parameterRefKinds, Byte refKind, ITypeSymbol returnType, Object diagnostics) => (IMethodSymbol)Invoke(70, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol"), nameof(CreateLambdaSymbol), compilation, containingSymbol, unboundLambda, parameterTypes, parameterRefKinds, refKind, returnType, diagnostics);
        public static IMethodSymbol CreateLambdaSymbol(ISymbol containingSymbol, Int32 messageID, SyntaxNode syntax, Boolean isSynthesized) => (IMethodSymbol)Invoke(71, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol"), nameof(CreateLambdaSymbol), containingSymbol, messageID, syntax, isSynthesized);
        public static IMethodSymbol CreateLocalFunctionSymbol(Object binder, ISymbol containingSymbol, LocalFunctionStatementSyntax syntax) => (IMethodSymbol)Invoke(72, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LocalFunctionSymbol"), nameof(CreateLocalFunctionSymbol), binder, containingSymbol, syntax);
        public static IParameterSymbol CreateSourceClonedParameterSymbol(IParameterSymbol originalParam, ISymbol newOwner, Int32 newOrdinal, Boolean suppressOptional) => (IParameterSymbol)Invoke(73, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceClonedParameterSymbol"), nameof(CreateSourceClonedParameterSymbol), originalParam, newOwner, newOrdinal, suppressOptional);
        public static IParameterSymbol CreateSourceComplexParameterSymbolWithCustomModifiers(ISymbol owner, Int32 ordinal, ITypeSymbol parameterType, Byte refKind, ImmutableArray<CustomModifier> customModifiers, ImmutableArray<CustomModifier> refCustomModifiers, String name, ImmutableArray<Location> locations, SyntaxReference syntaxRef, Object defaultSyntaxValue, Boolean isParams, Boolean isExtensionMethodThis) => (IParameterSymbol)Invoke(74, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolWithCustomModifiers"), nameof(CreateSourceComplexParameterSymbolWithCustomModifiers), owner, ordinal, parameterType, refKind, customModifiers, refCustomModifiers, name, locations, syntaxRef, defaultSyntaxValue, isParams, isExtensionMethodThis);
        public static IMethodSymbol CreateConstructorSymbol(INamedTypeSymbol containingType, ConstructorDeclarationSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(75, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceConstructorSymbol"), containingType, syntax, diagnostics);
        public static IMethodSymbol CreateSourceConstructorSymbol(INamedTypeSymbol containingType, Location location, ConstructorDeclarationSyntax syntax, Int32 methodKind, Object diagnostics) => (IMethodSymbol)Invoke(76, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceConstructorSymbol"), nameof(CreateSourceConstructorSymbol), containingType, location, syntax, methodKind, diagnostics);
        public static IMethodSymbol CreateSourceCustomEventAccessorSymbol(IEventSymbol @event, AccessorDeclarationSyntax syntax, IEventSymbol explicitlyImplementedEventOpt, String aliasQualifierOpt, Object diagnostics) => (IMethodSymbol)Invoke(77, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventAccessorSymbol"), nameof(CreateSourceCustomEventAccessorSymbol), @event, syntax, explicitlyImplementedEventOpt, aliasQualifierOpt, diagnostics);
        public static IEventSymbol CreateSourceCustomEventSymbol(INamedTypeSymbol containingType, Object binder, EventDeclarationSyntax syntax, Object diagnostics) => (IEventSymbol)Invoke(78, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"), nameof(CreateSourceCustomEventSymbol), containingType, binder, syntax, diagnostics);
        public static IMethodSymbol CreateSourceDestructorSymbol(INamedTypeSymbol containingType, DestructorDeclarationSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(79, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceDestructorSymbol"), nameof(CreateSourceDestructorSymbol), containingType, syntax, diagnostics);
        public static IFieldSymbol CreateSourceEventFieldSymbol(IEventSymbol associatedEvent, VariableDeclaratorSyntax declaratorSyntax, Object discardedDiagnostics) => (IFieldSymbol)Invoke(80, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventFieldSymbol"), nameof(CreateSourceEventFieldSymbol), associatedEvent, declaratorSyntax, discardedDiagnostics);
        public static IEventSymbol CreateSourceFieldLikeEventSymbol(INamedTypeSymbol containingType, Object binder, SyntaxTokenList modifiers, VariableDeclaratorSyntax declaratorSyntax, Object diagnostics) => (IEventSymbol)Invoke(81, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"), nameof(CreateSourceFieldLikeEventSymbol), containingType, binder, modifiers, declaratorSyntax, diagnostics);
        public static INamedTypeSymbol CreateFixedFieldImplementationType(IFieldSymbol field) => (INamedTypeSymbol)Invoke(82, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.FixedFieldImplementationType"), nameof(CreateFixedFieldImplementationType), field);
        public static ILabelSymbol CreateSourceLabelSymbol(IMethodSymbol containingMethod, SyntaxNodeOrToken identifierNodeOrToken, Object switchCaseLabelConstant = null) => (ILabelSymbol)Invoke(83, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol"), nameof(CreateSourceLabelSymbol), containingMethod, identifierNodeOrToken, switchCaseLabelConstant);
        public static ILabelSymbol CreateSourceLabelSymbol(IMethodSymbol containingMethod, Object switchCaseLabelConstant) => (ILabelSymbol)Invoke(84, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol"), nameof(CreateSourceLabelSymbol), containingMethod, switchCaseLabelConstant);
        public static IMethodSymbol CreateMethodSymbol(INamedTypeSymbol containingType, Object bodyBinder, MethodDeclarationSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(85, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol"), containingType, bodyBinder, syntax, diagnostics);
        public static IMethodSymbol CreateSourceMemberMethodSymbol(INamedTypeSymbol containingType, ITypeSymbol explicitInterfaceType, String name, Location location, MethodDeclarationSyntax syntax, Int32 methodKind, Object diagnostics) => (IMethodSymbol)Invoke(86, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol"), nameof(CreateSourceMemberMethodSymbol), containingType, explicitInterfaceType, name, location, syntax, methodKind, diagnostics);
        public static IModuleSymbol CreateSourceModuleSymbol(ISourceAssemblySymbol assemblySymbol, Object declarations, String moduleName) => (IModuleSymbol)Invoke(87, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol"), nameof(CreateSourceModuleSymbol), assemblySymbol, declarations, moduleName);
        public static INamedTypeSymbol CreateSourceNamedTypeSymbol(INamespaceOrTypeSymbol containingSymbol, Object declaration, Object diagnostics) => (INamedTypeSymbol)Invoke(88, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol"), nameof(CreateSourceNamedTypeSymbol), containingSymbol, declaration, diagnostics);
        public static IMethodSymbol CreateAccessorSymbol(INamedTypeSymbol containingType, IPropertySymbol property, Int32 propertyModifiers, String propertyName, AccessorDeclarationSyntax syntax, IPropertySymbol explicitlyImplementedPropertyOpt, String aliasQualifierOpt, Boolean isAutoPropertyAccessor, Object diagnostics) => (IMethodSymbol)Invoke(89, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol"), containingType, property, propertyModifiers, propertyName, syntax, explicitlyImplementedPropertyOpt, aliasQualifierOpt, isAutoPropertyAccessor, diagnostics);
        public static IMethodSymbol CreateAccessorSymbol(INamedTypeSymbol containingType, IPropertySymbol property, Int32 propertyModifiers, String propertyName, ArrowExpressionClauseSyntax syntax, IPropertySymbol explicitlyImplementedPropertyOpt, String aliasQualifierOpt, Object diagnostics) => (IMethodSymbol)Invoke(90, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol"), containingType, property, propertyModifiers, propertyName, syntax, explicitlyImplementedPropertyOpt, aliasQualifierOpt, diagnostics);
        public static IMethodSymbol CreateSourcePropertyAccessorSymbol(INamedTypeSymbol containingType, String name, IPropertySymbol property, Int32 propertyModifiers, ImmutableArray<ISymbol> explicitInterfaceImplementations, Location location, ArrowExpressionClauseSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(91, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol"), nameof(CreateSourcePropertyAccessorSymbol), containingType, name, property, propertyModifiers, explicitInterfaceImplementations, location, syntax, diagnostics);
        public static IMethodSymbol CreateSourcePropertyAccessorSymbol(INamedTypeSymbol containingType, String name, IPropertySymbol property, Int32 propertyModifiers, ImmutableArray<ISymbol> explicitInterfaceImplementations, Location location, AccessorDeclarationSyntax syntax, Int32 methodKind, Boolean isAutoPropertyAccessor, Object diagnostics) => (IMethodSymbol)Invoke(92, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol"), nameof(CreateSourcePropertyAccessorSymbol), containingType, name, property, propertyModifiers, explicitInterfaceImplementations, location, syntax, methodKind, isAutoPropertyAccessor, diagnostics);
        public static IPropertySymbol CreateSourcePropertySymbol(INamedTypeSymbol containingType, Object bodyBinder, BasePropertyDeclarationSyntax syntax, String name, Location location, Object diagnostics) => (IPropertySymbol)Invoke(93, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol"), nameof(CreateSourcePropertySymbol), containingType, bodyBinder, syntax, name, location, diagnostics);
        public static IParameterSymbol CreateSourceSimpleParameterSymbol(ISymbol owner, ITypeSymbol parameterType, Int32 ordinal, Byte refKind, String name, ImmutableArray<Location> locations) => (IParameterSymbol)Invoke(94, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceSimpleParameterSymbol"), nameof(CreateSourceSimpleParameterSymbol), owner, parameterType, ordinal, refKind, name, locations);
        public static ITypeParameterSymbol CreateSourceTypeParameterSymbol(INamedTypeSymbol owner, String name, Int32 ordinal, Int16 varianceKind, ImmutableArray<Location> locations, ImmutableArray<SyntaxReference> syntaxRefs) => (ITypeParameterSymbol)Invoke(95, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbol"), nameof(CreateSourceTypeParameterSymbol), owner, name, ordinal, varianceKind, locations, syntaxRefs);
        public static ITypeParameterSymbol CreateSourceMethodTypeParameterSymbol(IMethodSymbol owner, String name, Int32 ordinal, ImmutableArray<Location> locations, ImmutableArray<SyntaxReference> syntaxRefs) => (ITypeParameterSymbol)Invoke(96, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodTypeParameterSymbol"), nameof(CreateSourceMethodTypeParameterSymbol), owner, name, ordinal, locations, syntaxRefs);
        public static ITypeParameterSymbol CreateLocalFunctionTypeParameterSymbol(IMethodSymbol owner, String name, Int32 ordinal, ImmutableArray<Location> locations, ImmutableArray<SyntaxReference> syntaxRefs) => (ITypeParameterSymbol)Invoke(97, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.LocalFunctionTypeParameterSymbol"), nameof(CreateLocalFunctionTypeParameterSymbol), owner, name, ordinal, locations, syntaxRefs);
        public static Object CreateOverriddenMethodTypeParameterMap(IMethodSymbol overridingMethod) => (Object)Invoke(98, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenMethodTypeParameterMap"), nameof(CreateOverriddenMethodTypeParameterMap), overridingMethod);
        public static Object CreateExplicitInterfaceMethodTypeParameterMap(IMethodSymbol implementationMethod) => (Object)Invoke(99, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ExplicitInterfaceMethodTypeParameterMap"), nameof(CreateExplicitInterfaceMethodTypeParameterMap), implementationMethod);
        public static ITypeParameterSymbol CreateSourceOverridingMethodTypeParameterSymbol(Object map, String name, Int32 ordinal, ImmutableArray<Location> locations, ImmutableArray<SyntaxReference> syntaxRefs) => (ITypeParameterSymbol)Invoke(100, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol"), nameof(CreateSourceOverridingMethodTypeParameterSymbol), map, name, ordinal, locations, syntaxRefs);
        public static IMethodSymbol CreateUserDefinedConversionSymbol(INamedTypeSymbol containingType, ConversionOperatorDeclarationSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(101, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedConversionSymbol"), containingType, syntax, diagnostics);
        public static IMethodSymbol CreateSourceUserDefinedConversionSymbol(INamedTypeSymbol containingType, String name, Location location, ConversionOperatorDeclarationSyntax syntax, Object diagnostics, Boolean isExpressionBodied) => (IMethodSymbol)Invoke(102, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedConversionSymbol"), nameof(CreateSourceUserDefinedConversionSymbol), containingType, name, location, syntax, diagnostics, isExpressionBodied);
        public static IMethodSymbol CreateUserDefinedOperatorSymbol(INamedTypeSymbol containingType, OperatorDeclarationSyntax syntax, Object diagnostics) => (IMethodSymbol)Invoke(103, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbol"), containingType, syntax, diagnostics);
        public static IMethodSymbol CreateSourceUserDefinedOperatorSymbol(INamedTypeSymbol containingType, String name, Location location, OperatorDeclarationSyntax syntax, Object diagnostics, Boolean isExpressionBodied) => (IMethodSymbol)Invoke(104, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbol"), nameof(CreateSourceUserDefinedOperatorSymbol), containingType, name, location, syntax, diagnostics, isExpressionBodied);
        public static AttributeData CreateSynthesizedAttributeData(IMethodSymbol wellKnownMember, ImmutableArray<TypedConstant> arguments, ImmutableArray<KeyValuePair<String, TypedConstant>> namedArguments) => (AttributeData)Invoke(105, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData"), nameof(CreateSynthesizedAttributeData), wellKnownMember, arguments, namedArguments);
        public static IParameterSymbol CreateThisParameterSymbol(IMethodSymbol forMethod) => (IParameterSymbol)Invoke(106, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ThisParameterSymbol"), nameof(CreateThisParameterSymbol), forMethod);
        public static IParameterSymbol CreateThisParameterSymbol(IMethodSymbol forMethod, ITypeSymbol containingType) => (IParameterSymbol)Invoke(107, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ThisParameterSymbol"), nameof(CreateThisParameterSymbol), forMethod, containingType);
        public static Object CreateTypeParameterBuilder(SyntaxReference syntaxRef, INamedTypeSymbol owner, Location location) => (Object)Invoke(108, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBuilder"), nameof(CreateTypeParameterBuilder), syntaxRef, owner, location);
        public static Object CreateTypeParameterConstraintClause(Int32 constraints, ImmutableArray<INamespaceOrTypeSymbol> constraintTypes) => (Object)Invoke(109, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause"), nameof(CreateTypeParameterConstraintClause), constraints, constraintTypes);
        public static IEventSymbol CreateSubstitutedEventSymbol(INamedTypeSymbol containingType, IEventSymbol originalDefinition) => (IEventSymbol)Invoke(110, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedEventSymbol"), nameof(CreateSubstitutedEventSymbol), containingType, originalDefinition);
        public static IFieldSymbol CreateSubstitutedFieldSymbol(INamedTypeSymbol containingType, IFieldSymbol substitutedFrom) => (IFieldSymbol)Invoke(111, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedFieldSymbol"), nameof(CreateSubstitutedFieldSymbol), containingType, substitutedFrom);
        public static IParameterSymbol CreateSubstitutedParameterSymbol(IMethodSymbol containingSymbol, Object map, IParameterSymbol originalParameter) => (IParameterSymbol)Invoke(112, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedParameterSymbol"), nameof(CreateSubstitutedParameterSymbol), containingSymbol, map, originalParameter);
        public static IParameterSymbol CreateSubstitutedParameterSymbol(IPropertySymbol containingSymbol, Object map, IParameterSymbol originalParameter) => (IParameterSymbol)Invoke(113, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedParameterSymbol"), nameof(CreateSubstitutedParameterSymbol), containingSymbol, map, originalParameter);
        public static IParameterSymbol CreateSubstitutedParameterSymbol(ISymbol containingSymbol, Object map, IParameterSymbol originalParameter) => (IParameterSymbol)Invoke(114, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedParameterSymbol"), nameof(CreateSubstitutedParameterSymbol), containingSymbol, map, originalParameter);
        public static IPropertySymbol CreateSubstitutedPropertySymbol(INamedTypeSymbol containingType, IPropertySymbol originalDefinition) => (IPropertySymbol)Invoke(115, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedPropertySymbol"), nameof(CreateSubstitutedPropertySymbol), containingType, originalDefinition);
        public static ILabelSymbol CreateGeneratedLabelSymbol(String name) => (ILabelSymbol)Invoke(116, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol"), nameof(CreateGeneratedLabelSymbol), name);
        public static IParameterSymbol CreateSynthesizedAccessorValueParameterSymbol(IMethodSymbol accessor, ITypeSymbol paramType, Int32 ordinal, ImmutableArray<CustomModifier> customModifiers) => (IParameterSymbol)Invoke(117, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAccessorValueParameterSymbol"), nameof(CreateSynthesizedAccessorValueParameterSymbol), accessor, paramType, ordinal, customModifiers);
        public static IFieldSymbol CreateSynthesizedBackingFieldSymbol(IPropertySymbol property, String name, Boolean isReadOnly, Boolean isStatic, Boolean hasInitializer) => (IFieldSymbol)Invoke(118, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedBackingFieldSymbol"), nameof(CreateSynthesizedBackingFieldSymbol), property, name, isReadOnly, isStatic, hasInitializer);
        public static INamedTypeSymbol CreateSynthesizedDelegateSymbol(INamespaceOrTypeSymbol containingSymbol, String name, ITypeSymbol objectType, ITypeSymbol intPtrType, ITypeSymbol voidReturnTypeOpt, Int32 parameterCount, ValueType byRefParameters) => (INamedTypeSymbol)Invoke(119, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedDelegateSymbol"), nameof(CreateSynthesizedDelegateSymbol), containingSymbol, name, objectType, intPtrType, voidReturnTypeOpt, parameterCount, byRefParameters);
        public static IFieldSymbol CreateSynthesizedEnumValueFieldSymbol(INamedTypeSymbol containingEnum) => (IFieldSymbol)Invoke(120, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEnumValueFieldSymbol"), nameof(CreateSynthesizedEnumValueFieldSymbol), containingEnum);
        public static IMethodSymbol CreateSynthesizedFieldLikeEventAccessorSymbol(IEventSymbol @event, Boolean isAdder) => (IMethodSymbol)Invoke(121, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldLikeEventAccessorSymbol"), nameof(CreateSynthesizedFieldLikeEventAccessorSymbol), @event, isAdder);
        public static IFieldSymbol CreateSynthesizedFieldSymbol(INamedTypeSymbol containingType, ITypeSymbol type, String name, Boolean isPublic = false, Boolean isReadOnly = false, Boolean isStatic = false) => (IFieldSymbol)Invoke(122, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbol"), nameof(CreateSynthesizedFieldSymbol), containingType, type, name, isPublic, isReadOnly, isStatic);
        public static IMethodSymbol CreateSynthesizedIntrinsicOperatorSymbol(ITypeSymbol leftType, String name, ITypeSymbol rightType, ITypeSymbol returnType, Boolean isCheckedBuiltin) => (IMethodSymbol)Invoke(123, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedIntrinsicOperatorSymbol"), nameof(CreateSynthesizedIntrinsicOperatorSymbol), leftType, name, rightType, returnType, isCheckedBuiltin);
        public static IMethodSymbol CreateSynthesizedIntrinsicOperatorSymbol(ITypeSymbol container, String name, ITypeSymbol returnType, Boolean isCheckedBuiltin) => (IMethodSymbol)Invoke(124, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedIntrinsicOperatorSymbol"), nameof(CreateSynthesizedIntrinsicOperatorSymbol), container, name, returnType, isCheckedBuiltin);
        public static IFieldSymbol CreateSynthesizedLambdaCacheFieldSymbol(INamedTypeSymbol containingType, ITypeSymbol type, String name, IMethodSymbol topLevelMethod, Boolean isReadOnly, Boolean isStatic) => (IFieldSymbol)Invoke(125, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLambdaCacheFieldSymbol"), nameof(CreateSynthesizedLambdaCacheFieldSymbol), containingType, type, name, topLevelMethod, isReadOnly, isStatic);
        public static ILocalSymbol CreateSynthesizedLocal(IMethodSymbol containingMethodOpt, ITypeSymbol type, Int32 kind, SyntaxNode syntaxOpt = null, Boolean isPinned = false, Byte refKind = 0) => (ILocalSymbol)Invoke(126, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal"), nameof(CreateSynthesizedLocal), containingMethodOpt, type, kind, syntaxOpt, isPinned, refKind);
        public static IParameterSymbol Create(IMethodSymbol container, ITypeSymbol type, Int32 ordinal, Byte refKind, String name = "", ImmutableArray<CustomModifier> customModifiers = default(ImmutableArray<CustomModifier>), ImmutableArray<CustomModifier> refCustomModifiers = default(ImmutableArray<CustomModifier>)) => (IParameterSymbol)Invoke(127, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol"), container, type, ordinal, refKind, name, customModifiers, refCustomModifiers);
        public static IParameterSymbol CreateSynthesizedParameterSymbol(IMethodSymbol container, ITypeSymbol type, Int32 ordinal, Byte refKind, String name) => (IParameterSymbol)Invoke(128, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol"), nameof(CreateSynthesizedParameterSymbol), container, type, ordinal, refKind, name);
        public static IMethodSymbol CreateSynthesizedStaticConstructor(INamedTypeSymbol containingType) => (IMethodSymbol)Invoke(129, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStaticConstructor"), nameof(CreateSynthesizedStaticConstructor), containingType);
        public static IMethodSymbol CreateSynthesizedSubmissionConstructor(INamedTypeSymbol containingType, Object diagnostics) => (IMethodSymbol)Invoke(130, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubmissionConstructor"), nameof(CreateSynthesizedSubmissionConstructor), containingType, diagnostics);
        public static IMethodSymbol CreateSynthesizedInteractiveInitializerMethod(INamedTypeSymbol containingType, Object diagnostics) => (IMethodSymbol)Invoke(131, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInteractiveInitializerMethod"), nameof(CreateSynthesizedInteractiveInitializerMethod), containingType, diagnostics);
        public static ITypeParameterSymbol CreateSynthesizedSubstitutedTypeParameterSymbol(ISymbol owner, Object map, ITypeParameterSymbol substitutedFrom, Int32 ordinal) => (ITypeParameterSymbol)Invoke(132, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubstitutedTypeParameterSymbol"), nameof(CreateSynthesizedSubstitutedTypeParameterSymbol), owner, map, substitutedFrom, ordinal);
        public static ILocalSymbol CreateTypeSubstitutedLocalSymbol(ILocalSymbol originalVariable, ITypeSymbol type, ISymbol containingSymbol) => (ILocalSymbol)Invoke(133, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeSubstitutedLocalSymbol"), nameof(CreateTypeSubstitutedLocalSymbol), originalVariable, type, containingSymbol);
        public static Object CreateTypeMap(ImmutableArray<ITypeSymbol> from, ImmutableArray<ValueType> to, Boolean allowAlpha = false) => (Object)Invoke(134, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap"), nameof(CreateTypeMap), from, to, allowAlpha);
        public static Object CreateTypeMap(ImmutableArray<ITypeSymbol> from, ImmutableArray<ITypeSymbol> to, Boolean allowAlpha = false) => (Object)Invoke(135, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap"), nameof(CreateTypeMap), from, to, allowAlpha);
        public static Object CreateTypeMap(Object mapping) => (Object)Invoke(136, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap"), nameof(CreateTypeMap), mapping);
        public static Object CreateTypeMap(INamedTypeSymbol containingType, ImmutableArray<ITypeSymbol> typeParameters, ImmutableArray<ValueType> typeArguments) => (Object)Invoke(137, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap"), nameof(CreateTypeMap), containingType, typeParameters, typeArguments);
        public static Object CreateTypeMap() => (Object)Invoke(138, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap"), nameof(CreateTypeMap));
        public static Object CreateTypeParameterBounds(ImmutableArray<INamespaceOrTypeSymbol> constraintTypes, ImmutableArray<ITypeSymbol> interfaces, INamedTypeSymbol effectiveBaseClass, ITypeSymbol deducedBaseType) => (Object)Invoke(139, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds"), nameof(CreateTypeParameterBounds), constraintTypes, interfaces, effectiveBaseClass, deducedBaseType);
        public static Object CreateTypeParameterBounds() => (Object)Invoke(140, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds"), nameof(CreateTypeParameterBounds));
        public static ValueType CreateTypeWithModifiers(ITypeSymbol type, ImmutableArray<CustomModifier> customModifiers) => (ValueType)Invoke(141, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithModifiers"), nameof(CreateTypeWithModifiers), type, customModifiers);
        public static ValueType CreateTypeWithModifiers(ITypeSymbol type) => (ValueType)Invoke(142, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithModifiers"), nameof(CreateTypeWithModifiers), type);
        public static ImmutableArray<ValueType> CreateTypeArguments(ImmutableArray<ITypeSymbol> typeParameters, Int32 n, Object errorInfo) => (ImmutableArray<ValueType>)Invoke(143, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.UnboundArgumentErrorTypeSymbol"), typeParameters, n, errorInfo);
        public static IErrorTypeSymbol CreateUnboundArgumentErrorTypeSymbol(String name, Object errorInfo) => (IErrorTypeSymbol)Invoke(144, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.UnboundArgumentErrorTypeSymbol"), nameof(CreateUnboundArgumentErrorTypeSymbol), name, errorInfo);
        public static IErrorTypeSymbol CreateUnsupportedMetadataTypeSymbol(BadImageFormatException mrEx = null) => (IErrorTypeSymbol)Invoke(145, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.UnsupportedMetadataTypeSymbol"), nameof(CreateUnsupportedMetadataTypeSymbol), mrEx);
        public static IMethodSymbol CreateAnonymousTypeConstructorSymbol(INamedTypeSymbol container, ImmutableArray<ISymbol> properties) => (IMethodSymbol)Invoke(146, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeConstructorSymbol"), nameof(CreateAnonymousTypeConstructorSymbol), container, properties);
        public static IMethodSymbol CreateAnonymousTypePropertyGetAccessorSymbol(IPropertySymbol property) => (IMethodSymbol)Invoke(147, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypePropertyGetAccessorSymbol"), nameof(CreateAnonymousTypePropertyGetAccessorSymbol), property);
        public static IMethodSymbol CreateAnonymousTypeEqualsMethodSymbol(INamedTypeSymbol container) => (IMethodSymbol)Invoke(148, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeEqualsMethodSymbol"), nameof(CreateAnonymousTypeEqualsMethodSymbol), container);
        public static IMethodSymbol CreateAnonymousTypeGetHashCodeMethodSymbol(INamedTypeSymbol container) => (IMethodSymbol)Invoke(149, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeGetHashCodeMethodSymbol"), nameof(CreateAnonymousTypeGetHashCodeMethodSymbol), container);
        public static IMethodSymbol CreateAnonymousTypeToStringMethodSymbol(INamedTypeSymbol container) => (IMethodSymbol)Invoke(150, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeToStringMethodSymbol"), nameof(CreateAnonymousTypeToStringMethodSymbol), container);
        public static ValueType CreateSynthesizedDelegateKey(Int32 parameterCount, ValueType byRefs, Boolean returnsVoid, Int32 generation) => (ValueType)Invoke(151, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+SynthesizedDelegateKey"), nameof(CreateSynthesizedDelegateKey), parameterCount, byRefs, returnsVoid, generation);
        public static ValueType CreateSynthesizedDelegateValue(Object manager, INamedTypeSymbol @delegate) => (ValueType)Invoke(152, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+SynthesizedDelegateValue"), nameof(CreateSynthesizedDelegateValue), manager, @delegate);
        public static Object CreateAnonymousTypeComparer(CSharpCompilation compilation) => (Object)Invoke(153, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeComparer"), nameof(CreateAnonymousTypeComparer), compilation);
        public static INamedTypeSymbol CreateAnonymousTypePublicSymbol(Object manager, ValueType typeDescr) => (INamedTypeSymbol)Invoke(154, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypePublicSymbol"), nameof(CreateAnonymousTypePublicSymbol), manager, typeDescr);
        public static IFieldSymbol CreateAnonymousTypeFieldSymbol(IPropertySymbol property) => (IFieldSymbol)Invoke(155, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeFieldSymbol"), nameof(CreateAnonymousTypeFieldSymbol), property);
        public static IPropertySymbol CreateAnonymousTypePropertySymbol(INamedTypeSymbol container, ValueType field, ITypeSymbol fieldTypeSymbol) => (IPropertySymbol)Invoke(156, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypePropertySymbol"), nameof(CreateAnonymousTypePropertySymbol), container, field, fieldTypeSymbol);
        public static IPropertySymbol CreateAnonymousTypePropertySymbol(INamedTypeSymbol container, ValueType field) => (IPropertySymbol)Invoke(157, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypePropertySymbol"), nameof(CreateAnonymousTypePropertySymbol), container, field);
        public static Object CreateNameAndIndex(String name, Int32 index) => (Object)Invoke(158, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+NameAndIndex"), nameof(CreateNameAndIndex), name, index);
        public static INamedTypeSymbol CreateAnonymousTypeTemplateSymbol(Object manager, ValueType typeDescr) => (INamedTypeSymbol)Invoke(159, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeTemplateSymbol"), nameof(CreateAnonymousTypeTemplateSymbol), manager, typeDescr);
        public static ITypeParameterSymbol CreateAnonymousTypeParameterSymbol(ISymbol container, Int32 ordinal, String name) => (ITypeParameterSymbol)Invoke(160, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager+AnonymousTypeParameterSymbol"), nameof(CreateAnonymousTypeParameterSymbol), container, ordinal, name);
        public static IMethodSymbol CreateBaseMethodWrapperSymbol(INamedTypeSymbol containingType, IMethodSymbol methodBeingWrapped, SyntaxNode syntax, String name) => (IMethodSymbol)Invoke(161, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter+BaseMethodWrapperSymbol"), nameof(CreateBaseMethodWrapperSymbol), containingType, methodBeingWrapped, syntax, name);
        public static IArrayTypeSymbol CreateSZArray(ITypeSymbol elementType, INamedTypeSymbol array, ImmutableArray<ITypeSymbol> constructedInterfaces, ImmutableArray<CustomModifier> customModifiers) => (IArrayTypeSymbol)Invoke(162, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+SZArray"), nameof(CreateSZArray), elementType, array, constructedInterfaces, customModifiers);
        public static IArrayTypeSymbol CreateMDArrayNoSizesOrBounds(ITypeSymbol elementType, Int32 rank, INamedTypeSymbol array, ImmutableArray<CustomModifier> customModifiers) => (IArrayTypeSymbol)Invoke(163, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+MDArrayNoSizesOrBounds"), nameof(CreateMDArrayNoSizesOrBounds), elementType, rank, array, customModifiers);
        public static IArrayTypeSymbol CreateMDArrayWithSizesAndBounds(ITypeSymbol elementType, Int32 rank, ImmutableArray<Int32> sizes, ImmutableArray<Int32> lowerBounds, INamedTypeSymbol array, ImmutableArray<CustomModifier> customModifiers) => (IArrayTypeSymbol)Invoke(164, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+MDArrayWithSizesAndBounds"), nameof(CreateMDArrayWithSizesAndBounds), elementType, rank, sizes, lowerBounds, array, customModifiers);
        public static IMethodSymbol CreateSynthesizedEmbeddedAttributeConstructorSymbol(INamedTypeSymbol containingType) => (IMethodSymbol)Invoke(165, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEmbeddedAttributeSymbol+SynthesizedEmbeddedAttributeConstructorSymbol"), nameof(CreateSynthesizedEmbeddedAttributeConstructorSymbol), containingType);
        public static ValueType CreateCheckConstraintsArgs(CSharpCompilation currentCompilation, Object conversions, Location location, Object diagnostics) => (ValueType)Invoke(166, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper+CheckConstraintsArgs"), nameof(CreateCheckConstraintsArgs), currentCompilation, conversions, location, diagnostics);
        public static ITypeParameterSymbol CreateErrorTypeParameterSymbol(IErrorTypeSymbol container, String name, Int32 ordinal) => (ITypeParameterSymbol)Invoke(167, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol+ErrorTypeParameterSymbol"), nameof(CreateErrorTypeParameterSymbol), container, name, ordinal);
        public static IParameterSymbol CreateReducedExtensionMethodParameterSymbol(IMethodSymbol containingMethod, IParameterSymbol underlyingParameter) => (IParameterSymbol)Invoke(168, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol+ReducedExtensionMethodParameterSymbol"), nameof(CreateReducedExtensionMethodParameterSymbol), containingMethod, underlyingParameter);
        public static ValueType CreateFieldInfo(IFieldSymbol field, Boolean startsCycle) => (ValueType)Invoke(169, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers+FieldInfo"), nameof(CreateFieldInfo), field, startsCycle);
        public static Object CreateSourceLocationComparer(Dictionary<Compilation, Int32> compilationOrdering) => (Object)Invoke(170, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers+SourceLocationComparer"), nameof(CreateSourceLocationComparer), compilationOrdering);
        public static IMethodSymbol CreateConstructor(INamedTypeSymbol delegateType, ITypeSymbol voidType, ITypeSymbol objectType, ITypeSymbol intPtrType, DelegateDeclarationSyntax syntax) => (IMethodSymbol)Invoke(171, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol+Constructor"), nameof(CreateConstructor), delegateType, voidType, objectType, intPtrType, syntax);
        public static IMethodSymbol CreateInvokeMethod(INamedTypeSymbol delegateType, Byte refKind, ITypeSymbol returnType, DelegateDeclarationSyntax syntax, Object binder, Object diagnostics) => (IMethodSymbol)Invoke(172, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol+InvokeMethod"), nameof(CreateInvokeMethod), delegateType, refKind, returnType, syntax, binder, diagnostics);
        public static IMethodSymbol CreateBeginInvokeMethod(IMethodSymbol invoke, ITypeSymbol iAsyncResultType, ITypeSymbol objectType, ITypeSymbol asyncCallbackType, DelegateDeclarationSyntax syntax) => (IMethodSymbol)Invoke(173, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol+BeginInvokeMethod"), nameof(CreateBeginInvokeMethod), invoke, iAsyncResultType, objectType, asyncCallbackType, syntax);
        public static IMethodSymbol CreateEndInvokeMethod(IMethodSymbol invoke, ITypeSymbol iAsyncResultType, DelegateDeclarationSyntax syntax) => (IMethodSymbol)Invoke(174, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol+EndInvokeMethod"), nameof(CreateEndInvokeMethod), invoke, iAsyncResultType, syntax);
        public static IFieldSymbol CreateZeroValuedEnumConstantSymbol(INamedTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, Object diagnostics) => (IFieldSymbol)Invoke(175, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol+ZeroValuedEnumConstantSymbol"), nameof(CreateZeroValuedEnumConstantSymbol), containingEnum, syntax, diagnostics);
        public static IFieldSymbol CreateExplicitValuedEnumConstantSymbol(INamedTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, EqualsValueClauseSyntax initializer, Object diagnostics) => (IFieldSymbol)Invoke(176, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol+ExplicitValuedEnumConstantSymbol"), nameof(CreateExplicitValuedEnumConstantSymbol), containingEnum, syntax, initializer, diagnostics);
        public static IFieldSymbol CreateImplicitValuedEnumConstantSymbol(INamedTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, IFieldSymbol otherConstant, UInt32 otherConstantOffset, Object diagnostics) => (IFieldSymbol)Invoke(177, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol+ImplicitValuedEnumConstantSymbol"), nameof(CreateImplicitValuedEnumConstantSymbol), containingEnum, syntax, otherConstant, otherConstantOffset, diagnostics);
        public static ILocalSymbol CreateLocalWithInitializer(ISymbol containingSymbol, Object scopeBinder, TypeSyntax typeSyntax, SyntaxToken identifierToken, EqualsValueClauseSyntax initializer, Object initializerBinder, Byte declarationKind) => (ILocalSymbol)Invoke(178, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol+LocalWithInitializer"), nameof(CreateLocalWithInitializer), containingSymbol, scopeBinder, typeSyntax, identifierToken, initializer, initializerBinder, declarationKind);
        public static ILocalSymbol CreateForEachLocalSymbol(ISymbol containingSymbol, Object scopeBinder, TypeSyntax typeSyntax, SyntaxToken identifierToken, ExpressionSyntax collection, Byte declarationKind) => (ILocalSymbol)Invoke(179, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol+ForEachLocalSymbol"), nameof(CreateForEachLocalSymbol), containingSymbol, scopeBinder, typeSyntax, identifierToken, collection, declarationKind);
        public static ValueType CreateFlags(SByte specialType, Int32 declarationModifiers, Byte typeKind) => (ValueType)Invoke(180, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol+Flags"), nameof(CreateFlags), specialType, declarationModifiers, typeKind);
        public static Object CreateMembersAndInitializers(ImmutableArray<ISymbol> nonTypeNonIndexerMembers, ImmutableArray<ImmutableArray<ValueType>> staticInitializers, ImmutableArray<ImmutableArray<ValueType>> instanceInitializers, ImmutableArray<SyntaxReference> indexerDeclarations, Int32 staticInitializersSyntaxLength, Int32 instanceInitializersSyntaxLength) => (Object)Invoke(181, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol+MembersAndInitializers"), nameof(CreateMembersAndInitializers), nonTypeNonIndexerMembers, staticInitializers, instanceInitializers, indexerDeclarations, staticInitializersSyntaxLength, instanceInitializersSyntaxLength);
        public static ValueType CreateFlags(Int32 methodKind, Int32 declarationModifiers, Boolean returnsVoid, Boolean isExtensionMethod, Boolean isMetadataVirtualIgnoringModifiers = false) => (ValueType)Invoke(182, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol+Flags"), nameof(CreateFlags), methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isMetadataVirtualIgnoringModifiers);
        public static ValueType CreateNameToSymbolMapBuilder(Int32 capacity) => (ValueType)Invoke(183, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol+NameToSymbolMapBuilder"), nameof(CreateNameToSymbolMapBuilder), capacity);
        public static IMethodSymbol CreateDelegateConstructor(INamedTypeSymbol containingType, ITypeSymbol objectType, ITypeSymbol intPtrType) => (IMethodSymbol)Invoke(184, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedDelegateSymbol+DelegateConstructor"), nameof(CreateDelegateConstructor), containingType, objectType, intPtrType);
        public static IMethodSymbol CreateInvokeMethod(INamedTypeSymbol containingType, ValueType byRefParameters, ITypeSymbol voidReturnTypeOpt) => (IMethodSymbol)Invoke(185, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedDelegateSymbol+InvokeMethod"), nameof(CreateInvokeMethod), containingType, byRefParameters, voidReturnTypeOpt);
        public static IMethodSymbol CreateAsyncForwardEntryPoint(CSharpCompilation compilation, INamedTypeSymbol containingType, IMethodSymbol userMain) => (IMethodSymbol)Invoke(186, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol+AsyncForwardEntryPoint"), nameof(CreateAsyncForwardEntryPoint), compilation, containingType, userMain);
        public static IMethodSymbol CreateScriptEntryPoint(INamedTypeSymbol containingType, ITypeSymbol returnType, IMethodSymbol getAwaiterMethod, IMethodSymbol getResultMethod) => (IMethodSymbol)Invoke(187, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol+ScriptEntryPoint"), nameof(CreateScriptEntryPoint), containingType, returnType, getAwaiterMethod, getResultMethod);
        public static IMethodSymbol CreateSubmissionEntryPoint(INamedTypeSymbol containingType, ITypeSymbol returnType, ITypeSymbol submissionArrayType) => (IMethodSymbol)Invoke(188, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol+SubmissionEntryPoint"), nameof(CreateSubmissionEntryPoint), containingType, returnType, submissionArrayType);
        public static IParameterSymbol CreateSynthesizedOperatorParameterSymbol(IMethodSymbol container, ITypeSymbol type, Int32 ordinal, String name) => (IParameterSymbol)Invoke(189, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedIntrinsicOperatorSymbol+SynthesizedOperatorParameterSymbol"), nameof(CreateSynthesizedOperatorParameterSymbol), container, type, ordinal, name);
        public static IParameterSymbol CreateSynthesizedParameterSymbolWithCustomModifiers(IMethodSymbol container, ITypeSymbol type, Int32 ordinal, Byte refKind, String name, ImmutableArray<CustomModifier> customModifiers, ImmutableArray<CustomModifier> refCustomModifiers) => (IParameterSymbol)Invoke(190, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol+SynthesizedParameterSymbolWithCustomModifiers"), nameof(CreateSynthesizedParameterSymbolWithCustomModifiers), container, type, ordinal, refKind, name, customModifiers, refCustomModifiers);
        public static EqualityComparer<ITypeSymbol> CreateEqualsIgnoringComparer(Int32 comparison) => (EqualityComparer<ITypeSymbol>)Invoke(191, CSharpAssembly.GetType("Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol+EqualsIgnoringComparer"), nameof(CreateEqualsIgnoringComparer), comparison);
    }
}
