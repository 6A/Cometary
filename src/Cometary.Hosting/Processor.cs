using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using TypeInfo = System.Reflection.TypeInfo;

namespace Cometary
{
    /// <summary>
    ///   Compiles an <see cref="Assembly"/>, and lets it edit itself and its project,
    ///   before compiling it once again.
    /// </summary>
    [SuppressMessage("ReSharper", "InvocationIsSkipped")]
    [DebuggerDisplay("{" + nameof(GetDebuggerDisplay) + "()}")]
    public sealed class Processor : IDisposable
    {
        private bool _hasBeenProcessed;
        private bool _hasBeenEmitted;

        private bool _trackedChanges;
        private Dictionary<SyntaxTree, TextChange[]> _changes;

        private string GetDebuggerDisplay() => $"Processor for '{Compilation.AssemblyName}'{(_hasBeenEmitted ? "" : " (Not yet emitted)")}";

        /// <summary>
        ///   Gets the <see cref="CSharpCompilation"/> generated by this <see cref="Processor"/>.
        /// </summary>
        public CSharpCompilation Compilation { get; private set; }

        /// <summary>
        ///   Gets the <see cref="Microsoft.CodeAnalysis.Project"/> processed by this <see cref="Processor"/>.
        /// </summary>
        public Project Project { get; }

        /// <summary>
        ///   Gets the <see cref="Stream"/> in which the compiled assembly will be written.
        /// </summary>
        public MemoryStream AssemblyStream { get; }

        /// <summary>
        ///   Gets the <see cref="Stream"/> in which the symbols of the compiled assembly will be written.
        /// </summary>
        public MemoryStream SymbolsStream { get; }

        /// <summary>
        ///   Gets the unique ID of the <see cref="Processor"/>, also associated
        ///   to the emitted <see cref="Assembly"/>.
        /// </summary>
        public int ID { get; }

        /// <summary>
        ///   Gets or sets whether or not changes should be tracked by the processor.
        /// </summary>
        public bool TrackChanges { get; set; }

#if NET_CORE
        /// <summary>
        ///   Gets the .NET Core load context used to load assemblies.
        /// </summary>
        internal CometaryAssemblyLoadContext Context { get; } 
#else
        /// <summary>
        ///   Gets the object used for assembly resolution when loading the
        ///   emitted assembly.
        /// </summary>
        internal AssemblyResolver Resolver { get; }
#endif

        /// <summary>
        ///   Gets the <see cref="ProcessorHost"/> that created this <see cref="Processor"/>.
        /// </summary>
        internal ProcessorHost Host { get; }

        #region Events
        /// <summary>
        ///   Event triggered when a message is logged.
        /// </summary>
        public event EventHandler<ProcessingMessage> MessageLogged;

        /// <summary>
        ///   Event triggered when a warning is logged.
        /// </summary>
        public event EventHandler<ProcessingMessage> WarningLogged;

        /// <summary>
        ///   Event triggered when a debug message is logged.
        /// </summary>
        public event EventHandler<ProcessingMessage> DebugMessageLogged;

        internal void OnMessageLogged(ProcessingMessage msg) => MessageLogged?.Invoke(this, msg);

        internal void OnWarningLogged(ProcessingMessage msg) => WarningLogged?.Invoke(this, msg);

        internal void OnDebugMessageLogged(ProcessingMessage msg) => DebugMessageLogged?.Invoke(this, msg);
        #endregion

        internal Processor(int id, ProcessorHost host, Project project)
        {
#if NET_CORE
            Context    = new CometaryAssemblyLoadContext();
#else
            Resolver   = new AssemblyResolver();
#endif

            Host = host;
            ID   = id;

            Project = project;

            if (!project.ParseOptions.Features.ContainsKey(nameof(IOperation)))
            {
                Project = project.WithParseOptions(
                    project.ParseOptions.WithFeatures(
                        project.ParseOptions.Features.Concat(new[] { new KeyValuePair<string, string>(nameof(IOperation), "True") })
                    )
                );
            }

            AssemblyStream = new MemoryStream();
            SymbolsStream  = new MemoryStream();
        }

        /// <inheritdoc />
        public void Dispose()
        {
#if NET_CORE
            Context.Dispose();
#else
            Resolver.Dispose();
#endif
            AssemblyStream.Dispose();
            SymbolsStream.Dispose();
        }

        /// <summary>
        ///   Loads the emitted assembly in memory.
        /// </summary>
        private Assembly LoadAssembly()
        {
#if NET_CORE
            return Context.LoadFromStream(AssemblyStream, SymbolsStream);
#else
            return Assembly.Load(AssemblyStream.GetBuffer(), SymbolsStream.GetBuffer());
#endif
        }

        /// <summary>
        ///   Loads all references for later.
        /// </summary>
        private void LoadReferences(Solution solution, Compilation compilation)
        {
            void Register(string file)
            {
#if NET_CORE
                Context.Register(file);
#else
                Resolver.Register(file);
#endif
            }

            foreach (var @ref in compilation.References)
            {
                string display = @ref.Display;

                if (Host.SharedReferences.Contains(display))
                    continue;

                if (@ref is PortableExecutableReference peRef)
                {
                    Register(peRef.FilePath);
                    Host.SharedReferences.Add(display);
                }
                else if (@ref is CompilationReference cRef)
                {
                    Project project = solution?.GetProject(cRef.Compilation.Assembly);

                    if (project != null)
                    {
                        Register(project.OutputFilePath);
                        Host.SharedReferences.Add(display);
                    }
                }
            }
        }

        /// <summary>
        ///   Gets the <see cref="TypeInfo"/>s of all defined types in the given <paramref name="assembly"/>.
        /// </summary>
        private static IEnumerable<TypeInfo> GetTypesInAssembly(Assembly assembly) => assembly.GetTypes().Select(IntrospectionExtensions.GetTypeInfo);

        /// <summary>
        ///   Creates a new <see cref="CometaryConfigurator"/> object, and passes it to
        ///   every static method that matches the (<c>(<see cref="CometaryConfigurator"/>) => <see cref="CometaryConfigurator"/></c>)
        ///   signature, until <see cref="CometaryConfigurator.Build"/> is called.
        /// </summary>
        private CometaryConfigurator LoadConfiguration(CometaryConfigurator config, Assembly assembly)
        {
            Type configType = config.GetType();

            // Find matching methods
            try
            {
                foreach (MethodInfo method in GetTypesInAssembly(assembly).SelectMany(RuntimeReflectionExtensions.GetRuntimeMethods))
                {
                    if (!method.IsStatic || method.IsGenericMethod || method.ReturnType != configType)
                        continue;

                    ParameterInfo[] parameters = method.GetParameters();

                    if (parameters.Length != 1 || parameters[0].ParameterType != configType)
                        continue;

                    config = method.Invoke(null, new object[] { config }) as CometaryConfigurator;
                }
            }
            catch (ReflectionTypeLoadException e)
            {
                WarningLogged?.Invoke(this, new ProcessingMessage($"Could not load some types from {e.LoaderExceptions.OfType<BadImageFormatException>().FirstOrDefault()?.FileName ?? "an unknown assembly"}, continuing..."));
            }

            return config;
        }

        /// <summary>
        ///   Emits the compilation to the assembly and symbols <see cref="Stream"/>s.
        /// </summary>
        private async Task<bool> EmitToMemoryAsync(Compilation compilation, CancellationToken token)
        {
            AssemblyStream.SetLength(0);
            SymbolsStream.SetLength(0);

            List<Exception> exceptions = new List<Exception>();
            EmitResult result = await Task.Factory.StartNew(() => compilation.Emit(AssemblyStream, SymbolsStream, cancellationToken: token), token);

            foreach (Diagnostic diagnostic in result.Diagnostics)
            {
                SyntaxNode node = diagnostic.Location.SourceTree.GetRoot().FindNode(diagnostic.Location.SourceSpan);

                switch (diagnostic.Severity)
                {
                    case DiagnosticSeverity.Error:
                        exceptions.Add(node == null
                            ? new ProcessingException(diagnostic.Location.SourceSpan, diagnostic.GetMessage())
                            : new ProcessingException(node, diagnostic.GetMessage()));
                        break;
                    case DiagnosticSeverity.Warning:
                    case DiagnosticSeverity.Info:
                        (diagnostic.Severity == DiagnosticSeverity.Warning ? WarningLogged : MessageLogged)?.Invoke(
                            this, node == null
                            ? new ProcessingMessage(diagnostic.GetMessage(), diagnostic.Location.SourceSpan)
                            : new ProcessingMessage(diagnostic.GetMessage(), node)
                        );
                        break;
                }
            }

            switch (exceptions.Count)
            {
                case 0:
                    _hasBeenEmitted = true;
                    return result.Success;
                case 1:
                    throw exceptions[0];
                default:
                    throw new AggregateException(exceptions);
            }
        }

        /// <summary>
        ///   Initializes this processor asynchronously.
        /// </summary>
        internal async Task<CSharpCompilation> InitializeAsync(CancellationToken token = default(CancellationToken))
        {
            if (Compilation != null)
                return Compilation;

            Compilation = await Project.GetCompilationAsync(token) as CSharpCompilation;

            LoadReferences(Project.Solution, Compilation);

            return Compilation;
        }

        /// <summary>
        ///   Fully processes the target project.
        /// </summary>
        /// <exception cref="ProcessingException">Invalid syntax.</exception>
        /// <exception cref="Exception">Unknown error.</exception>
        /// <exception cref="AggregateException">Multiple issues.</exception>
        public async Task ProcessAsync(CancellationToken token = default(CancellationToken))
        {
            _hasBeenProcessed = _hasBeenEmitted = false;

            bool trackChanges = TrackChanges;
            var changes = trackChanges ? new Dictionary<SyntaxTree, TextChange[]>() : null;

            // Take care of extern methods
            PreprocessingRewriter ppRewriter = new PreprocessingRewriter();

            CSharpCompilation compilation = Compilation ?? await InitializeAsync(token);
            CSharpCompilation preprocessedCompilation = compilation;

            Debug.Assert(compilation != null);

            // ReSharper disable once PossibleNullReferenceException
            for (int i = 0; i < compilation.SyntaxTrees.Length; i++)
            {
                CSharpSyntaxTree tree = (CSharpSyntaxTree)compilation.SyntaxTrees[i];

                // ReSharper disable once PossibleNullReferenceException
                preprocessedCompilation = preprocessedCompilation.ReplaceSyntaxTree(
                    tree, tree.WithRootAndOptions(ppRewriter.Visit(tree.GetRoot()), tree.Options)
                );
            }

            // Compile to stream
            bool succeeded = await EmitToMemoryAsync(preprocessedCompilation, token);

            if (!succeeded)
                throw new Exception("Unknown error encountered whilst compiling for the first time.");

            // Retrieve assembly from stream
            Host.Log("Loading emitted assembly.");

#if NET_CORE
            Assembly assembly = Context.EmittedAssembly = LoadAssembly();
#else
            Assembly assembly = Resolver.EmittedAssembly = LoadAssembly();
#endif
            Host.EmittedAssemblies.Add(assembly, this);
            Meta.GetProcessorCore = () => this;

            Host.Log("Successfully loaded emitted assembly.");

            CometaryConfigurator config = new CometaryConfigurator();

            // Load visitors, and let 'em visit the streams
            foreach (AssemblyName refAssemblyName in assembly.GetReferencedAssemblies())
            {
                if (Host.SharedAssemblies.ContainsKey(refAssemblyName))
                    continue;

                try
                {
                    Assembly refAssembly = Assembly.Load(refAssemblyName);

                    config = LoadConfiguration(config, refAssembly);
                    Host.SharedAssemblies.Add(refAssemblyName, refAssembly);
                }
                catch
                {
                    // Whatever.
                }
            }

            config = LoadConfiguration(config, assembly);

            CometaryOptions options = config.Build();
            CometaryState state = new CometaryState(AssemblyStream, SymbolsStream, assembly, compilation);

            // Process assembly
            Host.Log("Processing assembly...");
            foreach (Hook hook in options.Hooks)
            {
                hook(state);
            }

            Host.EmittedAssemblies.Remove(assembly);

            // Re-compile assembly
            succeeded = await EmitToMemoryAsync(compilation, token);

            if (!succeeded)
                throw new Exception("Unknown error encountered whilst compiling for the second time.");

            // Visit streams again
            state.OnEmitted();

            Host.Log("Saving to output file...");

            _hasBeenProcessed = _hasBeenEmitted = true;

            // ReSharper disable once AssignmentInConditionalExpression
            if (_trackedChanges = trackChanges)
                _changes = changes;

            Compilation = compilation;
        }

        /// <summary>
        ///   Writes the processed assembly to the output file.
        /// </summary>
        /// <param name="outputFilePath">
        ///   The path to the file in which the assembly will be written.
        ///   If <see langword="null"/>, the file will be written to the default
        ///   <see cref="Microsoft.CodeAnalysis.Project.OutputFilePath"/>.
        /// </param>
        /// <param name="symbolsFilePath">
        ///   The path of the file in which the debugging symbols of the assembly will be written.
        ///   If <see langword="null"/>, the file will have the same path as the <paramref name="outputFilePath"/>,
        ///   but with the <c>.pdb</c> extension.
        /// </param>
        /// <param name="writeSymbols">
        ///   Whether the debugging symbols should be written to a file.
        /// </param>
        /// <param name="token"></param>
        public async Task WriteAssemblyAsync(string outputFilePath = null, string symbolsFilePath = null, bool writeSymbols = true, CancellationToken token = default(CancellationToken))
        {
            if (!_hasBeenProcessed)
                await ProcessAsync(token);

            if (outputFilePath == null)
                outputFilePath = Project.OutputFilePath;
            if (symbolsFilePath == null)
                symbolsFilePath = Path.ChangeExtension(outputFilePath, ".pdb");

            AssemblyStream.Position = 0;
            SymbolsStream.Position = 0;

            using (FileStream assemblyFile = File.Open(outputFilePath, FileMode.Create, FileAccess.ReadWrite))
                await AssemblyStream.CopyToAsync(assemblyFile);

            if (!writeSymbols)
                return;

            using (FileStream symbolsFile = File.Open(symbolsFilePath, FileMode.Create, FileAccess.ReadWrite))
                await SymbolsStream.CopyToAsync(symbolsFile);
        }

        /// <summary>
        ///   Returns the changes that occured during the process.
        /// </summary>
        public ILookup<SyntaxTree, TextChange> GetChanges()
        {
            if (!_trackedChanges)
                throw new InvalidOperationException("Changes weren't tracked.");

            return (from pair in _changes
                    from ch in pair.Value
                    select new KeyValuePair<SyntaxTree, TextChange>(pair.Key, ch))
                    .ToLookup(ch => ch.Key, ch => ch.Value);
        }

        /// <summary>
        ///   Outputs the new syntax trees to new files, respecting their original path.
        /// </summary>
        [SuppressMessage("ReSharper", "AssignNullToNotNullAttribute", Justification = "Bug in R# ignores Debug.Assert.")]
        public async Task OutputChangedSyntaxTreesAsync(Project project, string basePath = null, CancellationToken token = default(CancellationToken))
        {
            string projectDir = Path.GetDirectoryName(project.FilePath);

            Debug.Assert(projectDir != null);

            if (basePath == null)
            {
                basePath = Path.Combine(projectDir, "obj", "cometary-syntax");

                if (!Directory.Exists(basePath))
                    Directory.CreateDirectory(basePath);
            }
            else if (!Directory.Exists(basePath))
                throw new DirectoryNotFoundException("Output directory not found.");

            foreach (SyntaxTree syntaxTree in Compilation.SyntaxTrees)
            {
                string relPath = syntaxTree.FilePath;

                if (!relPath.StartsWith(projectDir, StringComparison.OrdinalIgnoreCase))
                    continue;

                relPath = Path.Combine(basePath, relPath.Substring(projectDir.Length + 1));

                // Make sure dir exists
                Directory.CreateDirectory(Path.GetDirectoryName(relPath));

                using (FileStream fs = File.Open(relPath, FileMode.Create, FileAccess.Write))
                using (TextWriter writer = new StreamWriter(fs, syntaxTree.Encoding))
                {
                    SourceText text = Formatter
                        .Format(await syntaxTree.GetRootAsync(token), Host.Workspace, null, token)
                        .GetText(syntaxTree.Encoding);

                    text.Write(writer, token);
                }
            }
        }
    }
}
