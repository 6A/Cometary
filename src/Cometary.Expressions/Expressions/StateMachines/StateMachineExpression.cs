using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Cometary.Expressions
{
    /// <summary>
    /// Represents an <see cref="Expression"/> that outputs a
    /// <see cref="LambdaExpression"/>, and saves its local variables in
    /// an array in order to have a persistent state.
    /// </summary>
    public abstract class StateMachineExpression : Expression
    {
        private readonly IList<LabelTarget> labelTargets;
        private readonly TrackingExpressionVisitor trackingVisitor;

        private ConstructorInfo _vsmCtor;
        private ParameterExpression _state;
        private Type _type;
        private LabelTarget _end;

        /// <summary>
        /// Gets the <see cref="Expression"/> that represents the
        /// current state of the state machine as a <see cref="VirtualStateMachine"/>.
        /// </summary>
        protected ParameterExpression State => _state;

        /// <inheritdoc />
        public sealed override bool CanReduce => true;

        /// <inheritdoc />
        public sealed override ExpressionType NodeType => ExpressionType.Extension;

        /// <inheritdoc />
        public abstract override Type Type { get; }

        /// <summary>
        /// Gets the type of the lambda generated by this <see cref="StateMachineExpression"/>.
        /// </summary>
        public Type LambdaType => _type ?? throw new InvalidOperationException();

        /// <summary>
        /// Gets the <see cref="LabelTarget"/> used when returning from the lambda.
        /// </summary>
        protected LabelTarget End => _end ?? throw new InvalidOperationException();

        /// <summary>
        /// Initializes the <see cref="StateMachineExpression"/>.
        /// </summary>
        /// <param name="returnType">
        /// The return type of the state machine. Can be <see langword="null" />, in which
        /// case <see cref="SetType(Type, Type, Type)"/> must be called at the end of the inheriting constructor.
        /// </param>
        /// <param name="smType">
        /// The type of the state machine; must inherit <see cref="VirtualStateMachine"/>.
        /// </param>
        protected StateMachineExpression()
        {
            trackingVisitor = new TrackingExpressionVisitor(Project);
            labelTargets = new LightList<LabelTarget>();
        }

        /// <summary>
        /// Sets the return type of the lambda to generate, and the type of the state machine used.
        /// </summary>
        protected void SetType(Type lambdaType, Type smType)
        {
            Requires.NotNull(lambdaType, nameof(lambdaType));
            Requires.NotNull(smType, nameof(smType));

            _type = lambdaType;
            _end  = Label(lambdaType, "end");

            _state = Parameter(smType, "state");
            _vsmCtor = smType.GetTypeInfo().DeclaredConstructors.First(x => x.GetParameters().Length == 0);
        }

        /// <summary>
        /// Generates a <see cref="LambdaExpression"/> that wraps the given <paramref name="body"/>,
        /// saving its variables into a state, and allowing it to return multiple times without
        /// losing its inner state.
        /// </summary>
        protected LambdaExpression GenerateLambda(Expression body, params ParameterExpression[] parameters)
        {
            body = trackingVisitor.Visit(body);

            // Create the switch cases to go to our previous state.
            LabelTarget[] targets = labelTargets.ToArray();
            SwitchCase[] cases = new SwitchCase[targets.Length + 1];

            LabelTarget startLabel = Label("start");
            cases[0] = SwitchCase(Goto(startLabel), Constant(0));

            for (int i = 1; i < cases.Length; i++)
            {
                cases[i] = SwitchCase(Goto(targets[i - 1]), Constant(i));
            }

            // Add a switch to the beginning of the body
            body = Block(
                Switch(
                    Field(State, VirtualStateMachine.StateField),
                    Throw(New(typeof(ArgumentOutOfRangeException))),
                    cases
                ),
                Label(startLabel),
                body,
                Assign(Field(State, VirtualStateMachine.StateField), Constant(cases.Length)),
                Label(End, Default(End.Type))
            );

            return Lambda(
                trackingVisitor.GenerateBody(body, State),
                parameters.Prepend(State)
            );
        }

        /// <summary>
        /// Returns a <see cref="LambdaExpression"/> wrapping the body.
        /// <para>
        /// Using <see cref="GenerateLambda(Expression, ParameterExpression[])"/>
        /// to generate said <see cref="LambdaExpression"/> is recommended.
        /// </para>
        /// </summary>
        protected abstract LambdaExpression ToLambda();


        /// <summary>
        /// Transforms the given <see cref="Expression"/> into another one, and returns the latter.
        /// </summary>
        protected virtual Expression Project(Expression node) => node;


        /// <summary>
        /// Returns an <see cref="Expression"/> that calls the lambda
        /// generated by this <see cref="StateMachineExpression"/>.
        /// </summary>
        /// <remarks>
        /// This method should only be overriden if additional parameters are added.
        /// </remarks>
        public override Expression Reduce() => Constant(Compile());


        /// <summary>
        /// Produces a <see cref="VirtualStateMachine"/> representing the
        /// inner expression tree.
        /// </summary>
        protected VirtualStateMachine Compile()
        {
            LambdaExpression lambda = ToLambda();
            VirtualStateMachine vsm = (VirtualStateMachine)_vsmCtor.Invoke(null);

            vsm.Initialize(trackingVisitor.Variables.ToArray(), labelTargets.Count + 1, lambda.Compile());

            return vsm;
        }

        /// <summary>
        /// Produces a <see cref="VirtualStateMachine"/> representing the
        /// inner expression tree, as an object of type <typeparamref name="TSM"/>.
        /// </summary>
        protected TSM Compile<TSM>() where TSM : class => Compile() as TSM;


        /// <summary>
        /// Returns an <see cref="Expression"/> that directly returns the
        /// given <paramref name="value"/>.
        /// </summary>
        protected Expression Return(Expression value)
        {
            int nth = labelTargets.Count + 1;
            LabelTarget label = Label($"L{nth}");

            labelTargets.Add(label);

            return Block(
                Assign(Field(State, VirtualStateMachine.StateField), Constant(nth)),
                Return(End, value),
                Label(label)
            );
        }

        /// <summary>
        /// Returns an <see cref="Expression"/> that directly returns.
        /// </summary>
        protected Expression Return() => Return(null);
    }
}
