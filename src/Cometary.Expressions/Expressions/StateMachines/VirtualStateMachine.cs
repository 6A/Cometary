using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Cometary.Expressions
{
    /// <summary>
    /// Represents a state machine generated by a <see cref="StateMachineExpression"/>.
    /// </summary>
    public abstract class VirtualStateMachine
    {
        internal const int FAULTED = -1;
        internal const int NOT_YET_STARTED = 0;

        private object[] _locals;
        private ReadOnlyCollection<object> _readOnlyLocals;

        private int _endState;

        internal int _state;
        internal Exception _exception;
        internal Delegate _next;

        internal VirtualStateMachine() { }

        /// <summary>
        /// Gets the numeric state of the state machine,
        /// as an <see cref="int"/>.
        /// <para>
        /// This number represents the position in the method
        /// of the state.
        /// </para>
        /// </summary>
        public int State => _state;

        /// <summary>
        /// Gets the <see cref="object"/> array in which local
        /// variables are stored.
        /// </summary>
        public ReadOnlyCollection<object> Locals => _readOnlyLocals;

        /// <summary>Gets whether or not the method this state machine represents has finished running.</summary>
        public bool IsCompleted => _state == _endState;

        /// <summary>Gets whether or not the method this state machine represents has thrown.</summary>
        public bool IsFaulted   => _state == FAULTED;

        /// <summary>Gets whether or not the method this state machine represents is currently running.</summary>
        public bool IsRunning   => IsStarted && !IsCompleted;

        /// <summary>Gets whether or not the method this state machine represents has ran, or is running.</summary>
        public bool IsStarted   => _state > NOT_YET_STARTED;

        /// <summary>
        /// Initializes the locals in this state machine.
        /// </summary>
        public virtual void Initialize()
        {
        }

        /// <summary>
        /// Resets this state machine as if it had never ran.
        /// </summary>
        public virtual void Reset()
        {
            _state = NOT_YET_STARTED;

            for (int i = 0; i < _locals.Length; i++)
            {
                object ith = _locals[i];
                _locals[i] = ith == null || !ith.GetType().GetTypeInfo().IsValueType
                    ? null : Activator.CreateInstance(ith.GetType());
            }

            Initialize();
        }

        /// <summary>
        /// Gets the exception thrown by the method represented by this state machine.
        /// </summary>
        /// <exception cref="InvalidOperationException">The state machine hasn't thrown.</exception>
        public Exception GetThrownException()
        {
            if (_exception == null)
                throw new InvalidOperationException("This state machine hasn't thrown.");

            return _exception;
        }

        internal void Initialize(ParameterExpression[] locals, int endState, Delegate next)
        {
            _locals = new object[locals.Length];
            _readOnlyLocals = new ReadOnlyCollection<object>(_locals);

            _endState = endState;
            _next = next;

            for (int i = 0; i < locals.Length; i++)
            {
                Type localType = locals[i].Type;
                _locals[i] = localType.GetTypeInfo().IsValueType ? Activator.CreateInstance(localType) : null;
            }

            Initialize();
        }

        #region Reflection
        internal static readonly TypeInfo Type = typeof(VirtualStateMachine).GetTypeInfo();

        internal static readonly MethodInfo ResetMethod   = Type.GetDeclaredMethod(nameof(Reset));

        internal static readonly FieldInfo LocalsField    = Type.GetDeclaredField(nameof(_locals));
        internal static readonly FieldInfo StateField     = Type.GetDeclaredField(nameof(_state));
        internal static readonly FieldInfo ExceptionField = Type.GetDeclaredField(nameof(_exception));

        internal static readonly MethodInfo InitializeMethod =
            Type.DeclaredMethods.First(x => x.Name == nameof(Initialize) && x.IsPublic);
        internal static readonly MethodInfo InternalInitializeMethod =
            Type.DeclaredMethods.First(x => x.Name == nameof(Initialize) && x.IsAssembly);
        #endregion
    }

    /// <inheritdoc />
    /// <typeparam name="SM">The type of this state machine.</typeparam>
    public abstract class VirtualStateMachine<SM> : VirtualStateMachine where SM : VirtualStateMachine<SM>
    {
        protected VirtualStateMachine()
        {
            if (GetType() != typeof(SM))
                throw new InvalidCastException("Invalid type given.");
        }

        /// <summary>
        /// Advances to the next step, returning an object of type <typeparamref name="T"/>.
        /// </summary>
        protected T Next<T>()
        {
            try
            {
                return ((Func<SM, T>)_next)((SM)this);
            }
            catch (Exception e)
            {
                _exception = e;
                _state = FAULTED;

                throw;
            }
        }

        /// <summary>
        /// Advances to the next step.
        /// </summary>
        protected void Next()
        {
            try
            {
                ((Action<SM>)_next)((SM)this);
            }
            catch (Exception e)
            {
                _exception = e;
                _state = FAULTED;

                throw;
            }
        }
    }
}
